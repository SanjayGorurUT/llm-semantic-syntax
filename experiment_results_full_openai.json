{
  "tic_tac_toe": {
    "openai": [
      {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (0, 0, 255)\nCROSS_COLOR = (255, 0, 0)\nBG_COLOR = (255, 255, 255)\n\n# Initialize the screen\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\n# Game variables\nboard = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = \"O\"  # O starts first\ngame_over = False\nwinner = None\n\n# Function to draw the game board\ndef draw_board():\n    screen.fill(BG_COLOR)\n    # Draw grid lines\n    for i in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (0, i * CELL_SIZE), (WINDOW_SIZE, i * CELL_SIZE), 5)\n        pygame.draw.line(screen, LINE_COLOR, (i * CELL_SIZE, 0), (i * CELL_SIZE, WINDOW_SIZE), 5)\n\n# Function to draw marks on the board\ndef draw_marks():\n    for r in range(GRID_SIZE):\n        for c in range(GRID_SIZE):\n            if board[r][c] == \"O\":\n                pygame.draw.circle(screen, CIRCLE_COLOR, (c * CELL_SIZE + CELL_SIZE // 2, r * CELL_SIZE + CELL_SIZE // 2), CELL_SIZE // 3, 5)\n            elif board[r][c] == \"X\":\n                pygame.draw.line(screen, CROSS_COLOR, (c * CELL_SIZE + 50, r * CELL_SIZE + 50), (c * CELL_SIZE + CELL_SIZE - 50, r * CELL_SIZE + CELL_SIZE - 50), 5)\n                pygame.draw.line(screen, CROSS_COLOR, (c * CELL_SIZE + 50, r * CELL_SIZE + CELL_SIZE - 50), (c * CELL_SIZE + CELL_SIZE - 50, r * CELL_SIZE + 50), 5)\n\n# Function to check for a winner\ndef check_winner():\n    global winner\n    # Check rows and columns\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] is not None:\n            winner = board[i][0]\n            return True\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] is not None:\n            winner = board[0][i]\n            return True\n\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        winner = board[0][0]\n        return True\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        winner = board[0][2]\n        return True\n\n    return False\n\n# Function to check for a tie\ndef check_tie():\n    return all(all(cell is not None for cell in row) for row in board)\n\n# Function to reset the game\ndef reset_game():\n    global board, current_player, game_over, winner\n    board = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = \"O\"\n    game_over = False\n    winner = None\n\n# Game loop\nwhile True:\n    draw_board()\n    draw_marks()\n\n    # Event handling\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX, mouseY = event.pos\n            clicked_row = mouseY // CELL_SIZE\n            clicked_col = mouseX // CELL_SIZE\n\n            if board[clicked_row][clicked_col] is None:\n                board[clicked_row][clicked_col] = current_player\n                if check_winner():\n                    game_over = True\n                elif check_tie():\n                    game_over = True\n                current_player = \"X\" if current_player == \"O\" else \"O\"\n\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                reset_game()\n\n    # Display winner or tie message\n    if game_over:\n        if winner:\n            print(f\"{winner} wins!\")\n        else:\n            print(\"It's a tie!\")\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_WIDTH = 15\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH\nSPACE = CELL_SIZE // 4\n\n# Colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic-Tac-Toe\")\nfont = pygame.font.Font(None, 74)\n\n# Game State\nboard = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = \"circle\"  # Circle starts first\ngame_over = False\n\ndef draw_board():\n    screen.fill(WHITE)\n    for x in range(1, GRID_SIZE):\n        pygame.draw.line(screen, BLACK, (0, CELL_SIZE * x), (WINDOW_SIZE, CELL_SIZE * x), LINE_WIDTH)\n        pygame.draw.line(screen, BLACK, (CELL_SIZE * x, 0), (CELL_SIZE * x, WINDOW_SIZE), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == \"circle\":\n                pygame.draw.circle(screen, BLACK, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[row][col] == \"cross\":\n                pygame.draw.line(screen, BLACK, (col * CELL_SIZE + SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, BLACK, (col * CELL_SIZE + SPACE, row * CELL_SIZE + SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), CROSS_WIDTH)\n\ndef check_win():\n    # Check rows and columns\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] != None:\n            return board[i][0]\n        if board[0][i] == board[1][i] == board[2][i] != None:\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != None:\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != None:\n        return board[0][2]\n\n    # Check for a tie\n    if all(cell is not None for row in board for cell in row):\n        return \"tie\"\n    \n    return None\n\ndef draw_winning_line(winner):\n    if winner == \"circle\":\n        color = GREEN\n    elif winner == \"cross\":\n        color = RED\n    else:\n        return\n\n    if winner in [\"circle\", \"cross\"]:\n        # Check rows and columns\n        for i in range(GRID_SIZE):\n            if board[i][0] == board[i][1] == board[i][2] == winner:\n                start_pos = (0, (i + 0.5) * CELL_SIZE)\n                end_pos = (WINDOW_SIZE, (i + 0.5) * CELL_SIZE)\n                pygame.draw.line(screen, color, start_pos, end_pos, LINE_WIDTH)\n                return\n            if board[0][i] == board[1][i] == board[2][i] == winner:\n                start_pos = ((i + 0.5) * CELL_SIZE, 0)\n                end_pos = ((i + 0.5) * CELL_SIZE, WINDOW_SIZE)\n                pygame.draw.line(screen, color, start_pos, end_pos, LINE_WIDTH)\n                return\n        \n        # Check diagonals\n        if board[0][0] == board[1][1] == board[2][2] == winner:\n            pygame.draw.line(screen, color, (0, 0), (WINDOW_SIZE, WINDOW_SIZE), LINE_WIDTH)\n        if board[0][2] == board[1][1] == board[2][0] == winner:\n            pygame.draw.line(screen, color, (WINDOW_SIZE, 0), (0, WINDOW_SIZE), LINE_WIDTH)\n\n# Game Loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        \n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0]\n            mouseY = event.pos[1]\n            row = mouseY // CELL_SIZE\n            col = mouseX // CELL_SIZE\n\n            if board[row][col] is None:\n                board[row][col] = current_player\n                winner = check_win()\n                if winner:\n                    game_over = True\n                current_player = \"cross\" if current_player == \"circle\" else \"circle\"\n\n        # Restart the game\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                board = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n                current_player = \"circle\"\n                game_over = False\n\n    draw_board()\n    draw_marks()\n    if game_over:\n        winner = check_win()\n        draw_winning_line(winner)\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_WIDTH = 15\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH // 5\nSPACE = CELL_SIZE // 4\n\n# Colors\nBG_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Tic Tac Toe')\nscreen.fill(BG_COLOR)\n\n# Game state\nboard = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = 'O'  # Player 1 uses 'O', Player 2 uses 'X'\ngame_over = False\n\ndef draw_lines():\n    # Draw horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, CELL_SIZE), (WINDOW_SIZE, CELL_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * CELL_SIZE), (WINDOW_SIZE, 2 * CELL_SIZE), LINE_WIDTH)\n    \n    # Draw vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (CELL_SIZE, 0), (CELL_SIZE, WINDOW_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * CELL_SIZE, 0), (2 * CELL_SIZE, WINDOW_SIZE), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), CROSS_WIDTH)\n\ndef check_win():\n    global game_over\n    # Check rows\n    for row in range(GRID_SIZE):\n        if board[row][0] == board[row][1] == board[row][2] is not None:\n            pygame.draw.line(screen, LINE_COLOR, (0, row * CELL_SIZE + CELL_SIZE // 2), (WINDOW_SIZE, row * CELL_SIZE + CELL_SIZE // 2), LINE_WIDTH)\n            game_over = True\n            \n    # Check columns\n    for col in range(GRID_SIZE):\n        if board[0][col] == board[1][col] == board[2][col] is not None:\n            pygame.draw.line(screen, LINE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, 0), (col * CELL_SIZE + CELL_SIZE // 2, WINDOW_SIZE), LINE_WIDTH)\n            game_over = True\n            \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] is not None:\n        pygame.draw.line(screen, LINE_COLOR, (0, 0), (WINDOW_SIZE, WINDOW_SIZE), LINE_WIDTH)\n        game_over = True\n    if board[0][2] == board[1][1] == board[2][0] is not None:\n        pygame.draw.line(screen, LINE_COLOR, (0, WINDOW_SIZE), (WINDOW_SIZE, 0), LINE_WIDTH)\n        game_over = True\n\ndef check_tie():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] is None:\n                return False\n    return True\n\ndef restart_game():\n    global board, current_player, game_over\n    board = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = 'O'\n    game_over = False\n    screen.fill(BG_COLOR)\n    draw_lines()\n\n# Main loop\ndraw_lines()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                restart_game()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0]\n            mouseY = event.pos[1]\n\n            clicked_row = mouseY // CELL_SIZE\n            clicked_col = mouseX // CELL_SIZE\n\n            if board[clicked_row][clicked_col] is None:\n                board[clicked_row][clicked_col] = current_player\n                draw_marks()\n                check_win()\n                if not game_over:\n                    if check_tie():\n                        print(\"It's a Tie!\")\n                    current_player = 'X' if current_player == 'O' else 'O'\n                    \n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 0 positional arguments but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\nimport numpy as np\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_WIDTH = 15\nBOARD_ROWS, BOARD_COLS = 3, 3\nSQUARE_SIZE = WIDTH // BOARD_COLS\nCIRCLE_RADIUS = SQUARE_SIZE // 3\nCIRCLE_WIDTH = 15\nCROSS_WIDTH = 25\nSPACE = SQUARE_SIZE // 4\nBG_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Initialize the game window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic Tac Toe\")\nscreen.fill(BG_COLOR)\n\n# Create the board\nboard = np.zeros((BOARD_ROWS, BOARD_COLS))\n\ndef draw_lines():\n    # Draw horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, SQUARE_SIZE), (WIDTH, SQUARE_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, SQUARE_SIZE * 2), (WIDTH, SQUARE_SIZE * 2), LINE_WIDTH)\n    # Draw vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (SQUARE_SIZE, 0), (SQUARE_SIZE, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (SQUARE_SIZE * 2, 0), (SQUARE_SIZE * 2, HEIGHT), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(BOARD_ROWS):\n        for col in range(BOARD_COLS):\n            if board[row][col] == 1:\n                pygame.draw.circle(screen, CIRCLE_COLOR, (int(col * SQUARE_SIZE + SQUARE_SIZE // 2), int(row * SQUARE_SIZE + SQUARE_SIZE // 2)), CIRCLE_RADIUS, CIRCLE_WIDTH)\n            elif board[row][col] == 2:\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), CROSS_WIDTH)\n\ndef mark_square(row, col, player):\n    board[row][col] = player\n\ndef available_square(row, col):\n    return board[row][col] == 0\n\ndef check_win(player):\n    # Check rows\n    for row in range(BOARD_ROWS):\n        if np.all(board[row] == player):\n            return True\n    # Check columns\n    for col in range(BOARD_COLS):\n        if np.all(board[:, col] == player):\n            return True\n    # Check diagonals\n    if np.all(np.diag(board) == player) or np.all(np.diag(np.fliplr(board)) == player):\n        return True\n    return False\n\ndef reset_game():\n    global board\n    board = np.zeros((BOARD_ROWS, BOARD_COLS))\n    screen.fill(BG_COLOR)\n    draw_lines()\n\n# Main game loop\nplayer = 1\ngame_over = False\ndraw_lines()\n\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                reset_game()\n                player = 1\n                game_over = False\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0]\n            mouseY = event.pos[1]\n\n            clicked_row = mouseY // SQUARE_SIZE\n            clicked_col = mouseX // SQUARE_SIZE\n\n            if available_square(clicked_row, clicked_col):\n                mark_square(clicked_row, clicked_col, player)\n                if check_win(player):\n                    game_over = True\n                player = player % 2 + 1  # Switch players\n\n            draw_marks()\n\n    if game_over:\n        pygame.display.set_caption(f\"Player {3 - player} Wins! Press 'R' to Restart\")\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 1 positional argument but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_WIDTH = 15\nBOARD_SIZE = 3\nCELL_SIZE = WIDTH // BOARD_SIZE\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH\nSPACE = CELL_SIZE // 4\n\n# Colors\nBG_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Game variables\nboard = [[None for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]\nplayer = 1   # Player 1 is circles (1), Player 2 is crosses (2)\ngame_over = False\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Tic Tac Toe')\nscreen.fill(BG_COLOR)\n\ndef draw_lines():\n    # Draw horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, CELL_SIZE), (WIDTH, CELL_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, CELL_SIZE * 2), (WIDTH, CELL_SIZE * 2), LINE_WIDTH)\n    # Draw vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (CELL_SIZE, 0), (CELL_SIZE, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (CELL_SIZE * 2, 0), (CELL_SIZE * 2, HEIGHT), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            if board[row][col] == 1:\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CIRCLE_RADIUS, CROSS_WIDTH)\n            elif board[row][col] == 2:\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), CROSS_WIDTH)\n\ndef check_win():\n    global game_over\n    # Check horizontal, vertical and diagonal\n    for i in range(BOARD_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] != None or board[0][i] == board[1][i] == board[2][i] != None:\n            game_over = True\n            return\n    if board[0][0] == board[1][1] == board[2][2] != None or board[0][2] == board[1][1] == board[2][0] != None:\n        game_over = True\n\ndef check_tie():\n    global game_over\n    if all(cell is not None for row in board for cell in row):\n        game_over = True\n\ndef reset_game():\n    global board, player, game_over\n    board = [[None for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]\n    player = 1\n    game_over = False\n    screen.fill(BG_COLOR)\n    draw_lines()\n\n# Main game loop\ndraw_lines()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                reset_game()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0]\n            mouseY = event.pos[1]\n\n            clicked_row = mouseY // CELL_SIZE\n            clicked_col = mouseX // CELL_SIZE\n\n            if board[clicked_row][clicked_col] is None:\n                board[clicked_row][clicked_col] = player\n                check_win()\n                check_tie()\n                player = 2 if player == 1 else 1\n\n    draw_marks()\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 0 positional arguments but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (255, 0, 0)\nCROSS_COLOR = (0, 0, 255)\nBACKGROUND_COLOR = (255, 255, 255)\nLINE_WIDTH = 15\nCIRCLE_RADIUS = 60\nCIRCLE_WIDTH = 15\nCROSS_WIDTH = 15\nSPACE = 55\n\n# Initialize Pygame\npygame.init()\n\n# Set up the window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\n# Game variables\nboard = [[None] * 3 for _ in range(3)]\nplayer_turn = True  # True for Player 1 (Circle), False for Player 2 (Cross)\ngame_over = False\nwinner = None\n\n# Function to draw the grid\ndef draw_grid():\n    # Vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (WIDTH // 3, 0), (WIDTH // 3, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * WIDTH // 3, 0), (2 * WIDTH // 3, HEIGHT), LINE_WIDTH)\n    # Horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, HEIGHT // 3), (WIDTH, HEIGHT // 3), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * HEIGHT // 3), (WIDTH, 2 * HEIGHT // 3), LINE_WIDTH)\n\n# Function to draw the marks\ndef draw_marks():\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * WIDTH // 3 + WIDTH // 6, row * HEIGHT // 3 + HEIGHT // 6), CIRCLE_RADIUS, CIRCLE_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // 3 + SPACE, row * HEIGHT // 3 + HEIGHT // 3 - SPACE), (col * WIDTH // 3 + WIDTH // 3 - SPACE, row * HEIGHT // 3 + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // 3 + SPACE, row * HEIGHT // 3 + SPACE), (col * WIDTH // 3 + WIDTH // 3 - SPACE, row * HEIGHT // 3 + HEIGHT // 3 - SPACE), CROSS_WIDTH)\n\n# Function to check for a win\ndef check_winner():\n    global winner\n    # Check rows\n    for row in range(3):\n        if board[row][0] == board[row][1] == board[row][2] and board[row][0] is not None:\n            winner = board[row][0]\n            pygame.draw.line(screen, (0, 255, 0), (0, row * HEIGHT // 3 + HEIGHT // 6), (WIDTH, row * HEIGHT // 3 + HEIGHT // 6), LINE_WIDTH)\n            return True\n    # Check columns\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n            winner = board[0][col]\n            pygame.draw.line(screen, (0, 255, 0), (col * WIDTH // 3 + WIDTH // 6, 0), (col * WIDTH // 3 + WIDTH // 6, HEIGHT), LINE_WIDTH)\n            return True\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        winner = board[0][0]\n        pygame.draw.line(screen, (0, 255, 0), (0, 0), (WIDTH, HEIGHT), LINE_WIDTH)\n        return True\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        winner = board[0][2]\n        pygame.draw.line(screen, (0, 255, 0), (WIDTH, 0), (0, HEIGHT), LINE_WIDTH)\n        return True\n    return False\n\n# Function to check for a tie\ndef check_tie():\n    return all(cell is not None for row in board for cell in row)\n\n# Function to reset the game\ndef reset_game():\n    global board, player_turn, game_over, winner\n    board = [[None] * 3 for _ in range(3)]\n    player_turn = True\n    game_over = False\n    winner = None\n\n# Main game loop\ndef main():\n    global game_over\n    screen.fill(BACKGROUND_COLOR)\n    draw_grid()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:\n                    reset_game()\n                    screen.fill(BACKGROUND_COLOR)\n                    draw_grid()\n\n            if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n                mouseX, mouseY = event.pos\n                clicked_row = mouseY // (HEIGHT // 3)\n                clicked_col = mouseX // (WIDTH // 3)\n\n                if board[clicked_row][clicked_col] is None:\n                    board[clicked_row][clicked_col] = 'O' if player_turn else 'X'\n                    player_turn = not player_turn\n                    draw_marks()\n\n                    if check_winner():\n                        game_over = True\n                    if check_tie():\n                        game_over = True\n\n        pygame.display.update()\n\n# Run the game\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (240, 240, 240)\nCROSS_COLOR = (240, 240, 240)\nBACKGROUND_COLOR = (30, 30, 30)\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\n# Game Variables\nboard = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = 'O'  # 'O' goes first\ngame_over = False\n\ndef draw_board():\n    screen.fill(BACKGROUND_COLOR)\n    for i in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (0, i * CELL_SIZE), (WINDOW_SIZE, i * CELL_SIZE), 5)\n        pygame.draw.line(screen, LINE_COLOR, (i * CELL_SIZE, 0), (i * CELL_SIZE, WINDOW_SIZE), 5)\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CELL_SIZE // 3, 15)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + 50, row * CELL_SIZE + 50), (col * CELL_SIZE + CELL_SIZE - 50, row * CELL_SIZE + CELL_SIZE - 50), 15)\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + 50, row * CELL_SIZE + CELL_SIZE - 50), (col * CELL_SIZE + CELL_SIZE - 50, row * CELL_SIZE + 50), 15)\n\ndef check_winner():\n    global game_over\n    for row in range(GRID_SIZE):\n        if board[row][0] == board[row][1] == board[row][2] and board[row][0] is not None:\n            draw_winning_line((0, row), (WINDOW_SIZE, row))\n            game_over = True\n            return board[row][0]\n\n    for col in range(GRID_SIZE):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n            draw_winning_line((col * CELL_SIZE + CELL_SIZE // 2, 0), (col * CELL_SIZE + CELL_SIZE // 2, WINDOW_SIZE))\n            game_over = True\n            return board[0][col]\n\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        draw_winning_line((0, 0), (WINDOW_SIZE, WINDOW_SIZE))\n        game_over = True\n        return board[0][0]\n\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        draw_winning_line((WINDOW_SIZE, 0), (0, WINDOW_SIZE))\n        game_over = True\n        return board[0][2]\n\n    if all(cell is not None for row in board for cell in row):\n        game_over = True\n        return 'Tie'\n    \n    return None\n\ndef draw_winning_line(start, end):\n    pygame.draw.line(screen, (255, 0, 0), start, end, 15)\n\ndef restart_game():\n    global board, current_player, game_over\n    board = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = 'O'\n    game_over = False\n\n# Main Game Loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouse_x, mouse_y = event.pos\n            row = mouse_y // CELL_SIZE\n            col = mouse_x // CELL_SIZE\n            if board[row][col] is None:\n                board[row][col] = current_player\n                if check_winner() is None:\n                    current_player = 'X' if current_player == 'O' else 'O'\n        if event.type == pygame.KEYDOWN and event.key == pygame.K_r:\n            restart_game()\n\n    draw_board()\n    draw_marks()\n    \n    if game_over:\n        font = pygame.font.Font(None, 74)\n        if 'Tie' in str(check_winner()):\n            text = font.render(\"Tie!\", True, (255, 255, 255))\n            screen.blit(text, (WINDOW_SIZE // 2 - text.get_width() // 2, WINDOW_SIZE // 2 - text.get_height() // 2))\n        else:\n            winner = check_winner()\n            text = font.render(f\"{winner} Wins!\", True, (255, 255, 255))\n            screen.blit(text, (WINDOW_SIZE // 2 - text.get_width() // 2, WINDOW_SIZE // 2 - text.get_height() // 2))\n\n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (240, 240, 240)\nCROSS_COLOR = (0, 0, 0)\nBG_COLOR = (255, 255, 255)\nLINE_WIDTH = 15\nCIRCLE_RADIUS = 60\nCIRCLE_WIDTH = 15\nCROSS_WIDTH = 25\nSPACE = 55\n\n# Game variables\nboard = [[None] * 3 for _ in range(3)]\ncurrent_player = 'Circle'  # 'Circle' or 'Cross'\ngame_over = False\n\n# Set up the display\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\ndef draw_board():\n    # Draw the grid lines\n    screen.fill(BG_COLOR)\n    # Vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (WIDTH/3, 0), (WIDTH/3, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * WIDTH/3, 0), (2 * WIDTH/3, HEIGHT), LINE_WIDTH)\n    # Horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, HEIGHT/3), (WIDTH, HEIGHT/3), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * HEIGHT/3), (WIDTH, 2 * HEIGHT/3), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == 'Circle':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (int(col * WIDTH / 3 + WIDTH / 6), int(row * HEIGHT / 3 + HEIGHT / 6)), CIRCLE_RADIUS, CIRCLE_WIDTH)\n            elif board[row][col] == 'Cross':\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH / 3 + SPACE, row * HEIGHT / 3 + HEIGHT / 3 - SPACE), (col * WIDTH / 3 + WIDTH / 3 - SPACE, row * HEIGHT / 3 + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH / 3 + SPACE, row * HEIGHT / 3 + SPACE), (col * WIDTH / 3 + WIDTH / 3 - SPACE, row * HEIGHT / 3 + HEIGHT / 3 - SPACE), CROSS_WIDTH)\n\ndef check_winner():\n    # Check for a winner\n    for row in range(3):\n        if board[row][0] == board[row][1] == board[row][2] != None:  # Check rows\n            return board[row][0]\n    \n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] != None:  # Check columns\n            return board[0][col]\n    \n    if board[0][0] == board[1][1] == board[2][2] != None:  # Check diagonal\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] != None:  # Check reverse diagonal\n        return board[0][2]\n    \n    return None\n\ndef check_tie():\n    return all(cell is not None for row in board for cell in row)\n\ndef reset_game():\n    global board, current_player, game_over\n    board = [[None] * 3 for _ in range(3)]\n    current_player = 'Circle'\n    game_over = False\n    draw_board()\n    draw_marks()\n\n# Game loop\ndraw_board()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Restart the game\n                reset_game()\n\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouse_x, mouse_y = event.pos\n            clicked_row = int(mouse_y // (HEIGHT / 3))\n            clicked_col = int(mouse_x // (WIDTH / 3))\n\n            if board[clicked_row][clicked_col] is None:\n                board[clicked_row][clicked_col] = current_player\n                winner = check_winner()\n                if winner:\n                    game_over = True\n                elif check_tie():\n                    game_over = True\n                current_player = 'Cross' if current_player == 'Circle' else 'Circle'\n                draw_board()\n                draw_marks()\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nGRID_SIZE = 3\nCELL_SIZE = WIDTH // GRID_SIZE\nLINE_WIDTH = 15\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = 25\nSPACE = CELL_SIZE // 4\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\n\n# Initialize pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic-Tac-Toe\")\nfont = pygame.font.Font(None, 74)\n\n# Game variables\nboard = [[None] * GRID_SIZE for _ in range(GRID_SIZE)]\ncurrent_player = \"O\"  # 'O' for Player 1 (circle) and 'X' for Player 2 (cross)\ngame_over = False\nwinner = None\n\ndef draw_board():\n    for x in range(1, GRID_SIZE):\n        pygame.draw.line(screen, BLACK, (CELL_SIZE * x, 0), (CELL_SIZE * x, HEIGHT), LINE_WIDTH)\n        pygame.draw.line(screen, BLACK, (0, CELL_SIZE * x), (WIDTH, CELL_SIZE * x), LINE_WIDTH)\n\ndef draw_marks():\n    for i in range(GRID_SIZE):\n        for j in range(GRID_SIZE):\n            if board[i][j] == \"O\":\n                pygame.draw.circle(screen, BLACK, (j * CELL_SIZE + CELL_SIZE // 2, i * CELL_SIZE + CELL_SIZE // 2), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[i][j] == \"X\":\n                pygame.draw.line(screen, BLACK, (j * CELL_SIZE + SPACE, i * CELL_SIZE + CELL_SIZE - SPACE), (j * CELL_SIZE + CELL_SIZE - SPACE, i * CELL_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, BLACK, (j * CELL_SIZE + SPACE, i * CELL_SIZE + SPACE), (j * CELL_SIZE + CELL_SIZE - SPACE, i * CELL_SIZE + CELL_SIZE - SPACE), CROSS_WIDTH)\n\ndef check_winner():\n    global game_over, winner\n    # Check rows, columns, and diagonals\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] and board[i][0] is not None:\n            game_over = True\n            winner = board[i][0]\n            return\n\n    for i in range(GRID_SIZE):\n        if board[0][i] == board[1][i] == board[2][i] and board[0][i] is not None:\n            game_over = True\n            winner = board[0][i]\n            return\n\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        game_over = True\n        winner = board[0][0]\n        return\n\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        game_over = True\n        winner = board[0][2]\n        return\n\n    if all(board[i][j] is not None for i in range(GRID_SIZE) for j in range(GRID_SIZE)):\n        game_over = True\n\ndef draw_winning_line():\n    if winner:\n        color = RED\n        if winner == \"O\":\n            player_index = 1\n        else:\n            player_index = 0\n\n        for i in range(GRID_SIZE):\n            if board[i][0] == winner and board[i][1] == winner and board[i][2] == winner:\n                pygame.draw.line(screen, color, (0, (i + 0.5) * CELL_SIZE), (WIDTH, (i + 0.5) * CELL_SIZE), LINE_WIDTH)\n                return\n            if board[0][i] == winner and board[1][i] == winner and board[2][i] == winner:\n                pygame.draw.line(screen, color, ((i + 0.5) * CELL_SIZE, 0), ((i + 0.5) * CELL_SIZE, HEIGHT), LINE_WIDTH)\n                return\n        if board[0][0] == winner and board[1][1] == winner and board[2][2] == winner:\n            pygame.draw.line(screen, color, (0, 0), (WIDTH, HEIGHT), LINE_WIDTH)\n            return\n        if board[0][2] == winner and board[1][1] == winner and board[2][0] == winner:\n            pygame.draw.line(screen, color, (WIDTH, 0), (0, HEIGHT), LINE_WIDTH)\n\ndef restart_game():\n    global board, current_player, game_over, winner\n    board = [[None] * GRID_SIZE for _ in range(GRID_SIZE)]\n    current_player = \"O\"\n    game_over = False\n    winner = None\n\n# Main game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            x, y = event.pos\n            row = y // CELL_SIZE\n            col = x // CELL_SIZE\n            if board[row][col] is None:\n                board[row][col] = current_player\n                check_winner()\n                current_player = \"X\" if current_player == \"O\" else \"O\"\n\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                restart_game()\n\n    screen.fill(WHITE)\n    draw_board()\n    draw_marks()\n    draw_winning_line()\n\n    if game_over:\n        if winner:\n            text = font.render(f\"{winner} wins!\", True, BLACK)\n        else:\n            text = font.render(\"It's a tie!\", True, BLACK)\n        screen.blit(text, (WIDTH // 2 - text.get_width() // 2, HEIGHT // 2 - text.get_height() // 2))\n\n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (240, 240, 240)\nCROSS_COLOR = (80, 80, 80)\nBG_COLOR = (255, 255, 255)\n\n# Initialize the game\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic Tac Toe\")\nfont = pygame.font.Font(None, 74)\n\n# Game variables\nboard = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = 'O'  # 'O' starts first\ngame_over = False\nwinner = None\n\ndef draw_board():\n    screen.fill(BG_COLOR)\n    for x in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (x * CELL_SIZE, 0), (x * CELL_SIZE, WINDOW_SIZE), 5)\n        pygame.draw.line(screen, LINE_COLOR, (0, x * CELL_SIZE), (WINDOW_SIZE, x * CELL_SIZE), 5)\n\ndef draw_marks():\n    for y in range(GRID_SIZE):\n        for x in range(GRID_SIZE):\n            if board[y][x] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (x * CELL_SIZE + CELL_SIZE // 2, y * CELL_SIZE + CELL_SIZE // 2), CELL_SIZE // 2 - 10, 10)\n            elif board[y][x] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (x * CELL_SIZE + 20, y * CELL_SIZE + 20), (x * CELL_SIZE + CELL_SIZE - 20, y * CELL_SIZE + CELL_SIZE - 20), 10)\n                pygame.draw.line(screen, CROSS_COLOR, (x * CELL_SIZE + CELL_SIZE - 20, y * CELL_SIZE + 20), (x * CELL_SIZE + 20, y * CELL_SIZE + CELL_SIZE - 20), 10)\n\ndef check_winner():\n    global winner\n    # Check rows and columns\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] != '':\n            winner = board[i][0]\n            return True\n        if board[0][i] == board[1][i] == board[2][i] != '':\n            winner = board[0][i]\n            return True\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != '':\n        winner = board[0][0]\n        return True\n    if board[0][2] == board[1][1] == board[2][0] != '':\n        winner = board[0][2]\n        return True\n    return False\n\ndef reset_game():\n    global board, current_player, game_over, winner\n    board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = 'O'\n    game_over = False\n    winner = None\n\n# Main game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN and event.key == pygame.K_r:\n            reset_game()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX, mouseY = event.pos\n            clicked_row = mouseY // CELL_SIZE\n            clicked_col = mouseX // CELL_SIZE\n            if board[clicked_row][clicked_col] == '':\n                board[clicked_row][clicked_col] = current_player\n                if check_winner():\n                    game_over = True\n                else:\n                    current_player = 'X' if current_player == 'O' else 'O'\n\n    draw_board()\n    draw_marks()\n\n    if game_over:\n        if winner:\n            text = font.render(f\"{winner} Wins!\", True, LINE_COLOR)\n            screen.blit(text, (WINDOW_SIZE // 3, WINDOW_SIZE // 3))\n        else:\n            text = font.render(\"It's a Tie!\", True, LINE_COLOR)\n            screen.blit(text, (WINDOW_SIZE // 3, WINDOW_SIZE // 3))\n\n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (255, 0, 0)\nCROSS_COLOR = (0, 0, 255)\nBG_COLOR = (255, 255, 255)\nLINE_WIDTH = 15\nCIRCLE_RADIUS = 60\nCROSS_WIDTH = 25\nSPACE = 55\n\n# Grid\nGRID_SIZE = 3\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Tic-Tac-Toe')\nscreen.fill(BG_COLOR)\n\n# Draw grid\ndef draw_grid():\n    # Vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (WIDTH//3, 0), (WIDTH//3, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (WIDTH*2//3, 0), (WIDTH*2//3, HEIGHT), LINE_WIDTH)\n    # Horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, HEIGHT//3), (WIDTH, HEIGHT//3), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, HEIGHT*2//3), (WIDTH, HEIGHT*2//3), LINE_WIDTH)\n\n# Draw marks\ndef draw_marks(board):\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * WIDTH // GRID_SIZE + WIDTH // (GRID_SIZE * 2), row * HEIGHT // GRID_SIZE + HEIGHT // (GRID_SIZE * 2)), CIRCLE_RADIUS, CROSS_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // GRID_SIZE + SPACE, row * HEIGHT // GRID_SIZE + HEIGHT // (GRID_SIZE * 2) - SPACE), (col * WIDTH // GRID_SIZE + WIDTH // (GRID_SIZE * 2) - SPACE, row * HEIGHT // GRID_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // GRID_SIZE + SPACE, row * HEIGHT // GRID_SIZE + SPACE), (col * WIDTH // GRID_SIZE + WIDTH // (GRID_SIZE * 2) - SPACE, row * HEIGHT // GRID_SIZE + HEIGHT // (GRID_SIZE * 2) - SPACE), CROSS_WIDTH)\n\n# Check for win conditions\ndef check_win(board):\n    # Check rows, columns, and diagonals\n    for row in range(GRID_SIZE):\n        if board[row][0] == board[row][1] == board[row][2] != '':\n            return board[row][0]\n    for col in range(GRID_SIZE):\n        if board[0][col] == board[1][col] == board[2][col] != '':\n            return board[0][col]\n    if board[0][0] == board[1][1] == board[2][2] != '':\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != '':\n        return board[0][2]\n    return None\n\n# Check for tie\ndef check_tie(board):\n    for row in board:\n        if '' in row:\n            return False\n    return True\n\ndef main():\n    board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    player = 'X'\n    game_active = True\n    winner = None\n\n    draw_grid()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:\n                    board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n                    player = 'X'\n                    game_active = True\n                    winner = None\n                    screen.fill(BG_COLOR)\n                    draw_grid()\n            if event.type == pygame.MOUSEBUTTONDOWN and game_active:\n                x, y = event.pos\n                row = y // (HEIGHT // GRID_SIZE)\n                col = x // (WIDTH // GRID_SIZE)\n\n                if board[row][col] == '':\n                    board[row][col] = player\n                    winner = check_win(board)\n                    if winner:\n                        game_active = False\n                    elif check_tie(board):\n                        game_active = False\n                    player = 'O' if player == 'X' else 'X'\n\n        draw_marks(board)\n\n        if winner:\n            font = pygame.font.Font(None, 74)\n            text = font.render(f'{winner} wins!', True, (0, 0, 0))\n            screen.blit(text, (WIDTH//4, HEIGHT//2))\n        elif not game_active and check_tie(board):\n            font = pygame.font.Font(None, 74)\n            text = font.render('Tie!', True, (0, 0, 0))\n            screen.blit(text, (WIDTH//4, HEIGHT//2))\n\n        pygame.display.flip()\n\nif __name__ == '__main__':\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 1 positional argument but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\nBG_COLOR = (28, 170, 156)\nGRID_SIZE = 3\nCELL_SIZE = WIDTH // GRID_SIZE\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic Tac Toe\")\nfont = pygame.font.Font(None, 74)\n\n# Game state\nboard = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = \"circle\"  # circle starts first\ngame_over = False\n\ndef draw_board():\n    # Draw grid lines\n    for i in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (0, i * CELL_SIZE), (WIDTH, i * CELL_SIZE), 5)\n        pygame.draw.line(screen, LINE_COLOR, (i * CELL_SIZE, 0), (i * CELL_SIZE, HEIGHT), 5)\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == \"circle\":\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CELL_SIZE // 3, 15)\n            elif board[row][col] == \"cross\":\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + 50, row * CELL_SIZE + 50), (col * CELL_SIZE + CELL_SIZE - 50, row * CELL_SIZE + CELL_SIZE - 50), 15)\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + 50, row * CELL_SIZE + CELL_SIZE - 50), (col * CELL_SIZE + CELL_SIZE - 50, row * CELL_SIZE + 50), 15)\n\ndef check_winner():\n    # Check rows and columns\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] != '':\n            return board[i][0]\n        if board[0][i] == board[1][i] == board[2][i] != '':\n            return board[0][i]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != '':\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != '':\n        return board[0][2]\n    \n    # Check for tie\n    if all(cell != '' for row in board for cell in row):\n        return 'tie'\n    \n    return None\n\ndef draw_winner_line(winner):\n    if winner != 'tie':\n        if winner == \"circle\":\n            color = CIRCLE_COLOR\n        else:\n            color = CROSS_COLOR\n        # Draw winning line\n        if winner == \"circle\":\n            for i in range(GRID_SIZE):\n                if board[i][0] == board[i][1] == board[i][2]:\n                    pygame.draw.line(screen, color, (0, i * CELL_SIZE + CELL_SIZE // 2), (WIDTH, i * CELL_SIZE + CELL_SIZE // 2), 15)\n                    break\n                if board[0][i] == board[1][i] == board[2][i]:\n                    pygame.draw.line(screen, color, (i * CELL_SIZE + CELL_SIZE // 2, 0), (i * CELL_SIZE + CELL_SIZE // 2, HEIGHT), 15)\n                    break\n            if board[0][0] == board[1][1] == board[2][2]:\n                pygame.draw.line(screen, color, (0, 0), (WIDTH, HEIGHT), 15)\n            if board[0][2] == board[1][1] == board[2][0]:\n                pygame.draw.line(screen, color, (WIDTH, 0), (0, HEIGHT), 15)\n\ndef reset_game():\n    global board, current_player, game_over\n    board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = \"circle\"\n    game_over = False\n    screen.fill(BG_COLOR)\n    draw_board()\n\n# Main game loop\nreset_game()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Restart the game\n                reset_game()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX, mouseY = event.pos\n            row, col = mouseY // CELL_SIZE, mouseX // CELL_SIZE\n            \n            if board[row][col] == '':\n                board[row][col] = current_player\n                winner = check_winner()\n                if winner:\n                    game_over = True\n                current_player = \"cross\" if current_player == \"circle\" else \"circle\"\n    \n    screen.fill(BG_COLOR)\n    draw_board()\n    draw_marks()\n    if game_over:\n        winner = check_winner()\n        draw_winner_line(winner)\n        if winner == \"circle\":\n            text = font.render(\"Circle wins!\", True, CIRCLE_COLOR)\n        elif winner == \"cross\":\n            text = font.render(\"Cross wins!\", True, CROSS_COLOR)\n        elif winner == 'tie':\n            text = font.render(\"It's a Tie!\", True, (255, 255, 255))\n        screen.blit(text, (WIDTH // 2 - text.get_width() // 2, HEIGHT // 2 - text.get_height() // 2))\n    \n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_WIDTH = 15\nBOARD_ROWS = 3\nBOARD_COLS = 3\nSQUARE_SIZE = WIDTH // BOARD_COLS\nCIRCLE_RADIUS = SQUARE_SIZE // 3\nCROSS_WIDTH = 25\nSPACE = SQUARE_SIZE // 4\n\n# Colors\nBG_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Game variables\nboard = [[None]*BOARD_COLS for _ in range(BOARD_ROWS)]\nplayer_turn = True\ngame_over = False\nwinning_line = None\n\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Tic Tac Toe')\n\ndef draw_lines():\n    # Horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, SQUARE_SIZE), (WIDTH, SQUARE_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * SQUARE_SIZE), (WIDTH, 2 * SQUARE_SIZE), LINE_WIDTH)\n    # Vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (SQUARE_SIZE, 0), (SQUARE_SIZE, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * SQUARE_SIZE, 0), (2 * SQUARE_SIZE, HEIGHT), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(BOARD_ROWS):\n        for col in range(BOARD_COLS):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), CROSS_WIDTH)\n\ndef check_winner():\n    global winning_line\n    # Check horizontal, vertical and diagonal\n    for row in range(BOARD_ROWS):\n        if board[row][0] == board[row][1] == board[row][2] and board[row][0] is not None:\n            winning_line = ((0, row * SQUARE_SIZE + SQUARE_SIZE // 2), (WIDTH, row * SQUARE_SIZE + SQUARE_SIZE // 2))\n            return board[row][0]\n    \n    for col in range(BOARD_COLS):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n            winning_line = ((col * SQUARE_SIZE + SQUARE_SIZE // 2, 0), (col * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT))\n            return board[0][col]\n    \n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        winning_line = ((0, 0), (WIDTH, HEIGHT))\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        winning_line = ((WIDTH, 0), (0, HEIGHT))\n        return board[0][2]\n    \n    return None\n\ndef restart_game():\n    global board, player_turn, game_over, winning_line\n    board = [[None]*BOARD_COLS for _ in range(BOARD_ROWS)]\n    player_turn = True\n    game_over = False\n    winning_line = None\n\ndef main():\n    global game_over\n    pygame.init()\n    screen.fill(BG_COLOR)\n    draw_lines()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n                mouseX = event.pos[0]\n                mouseY = event.pos[1]\n\n                clicked_row = mouseY // SQUARE_SIZE\n                clicked_col = mouseX // SQUARE_SIZE\n\n                if board[clicked_row][clicked_col] is None:\n                    board[clicked_row][clicked_col] = 'O' if player_turn else 'X'\n                    player_turn = not player_turn\n\n                    winner = check_winner()\n                    if winner:\n                        game_over = True\n            \n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:\n                    restart_game()\n        \n        screen.fill(BG_COLOR)\n        draw_lines()\n        draw_marks()\n\n        if game_over and winning_line:\n            pygame.draw.line(screen, (255, 0, 0), winning_line[0], winning_line[1], LINE_WIDTH)\n\n        pygame.display.update()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (255, 0, 0)\nCROSS_COLOR = (0, 0, 255)\nBG_COLOR = (255, 255, 255)\nLINE_WIDTH = 15\nCIRCLE_WIDTH = 15\nCROSS_WIDTH = 25\nRADIUS = 60\nSPACE = 15\n\n# Initialize pygame\npygame.init()\n\n# Create the game window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Tic Tac Toe')\n\n# Game Variables\nboard = [['' for _ in range(3)] for _ in range(3)]\nplayer = 'O'  # Start with player O\ngame_over = False\n\n# Draw the board\ndef draw_board():\n    screen.fill(BG_COLOR)\n    # Vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (WIDTH // 3, 0), (WIDTH // 3, HEIGHT), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * WIDTH // 3, 0), (2 * WIDTH // 3, HEIGHT), LINE_WIDTH)\n    # Horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, HEIGHT // 3), (WIDTH, HEIGHT // 3), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * HEIGHT // 3), (WIDTH, 2 * HEIGHT // 3), LINE_WIDTH)\n\n# Draw marks\ndef draw_marks():\n    for row in range(3):\n        for col in range(3):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * WIDTH // 3 + WIDTH // 6, row * HEIGHT // 3 + HEIGHT // 6), RADIUS, CIRCLE_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // 3 + SPACE, row * HEIGHT // 3 + HEIGHT // 3 - SPACE), (col * WIDTH // 3 + WIDTH // 3 - SPACE, row * HEIGHT // 3 + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * WIDTH // 3 + SPACE, row * HEIGHT // 3 + SPACE), (col * WIDTH // 3 + WIDTH // 3 - SPACE, row * HEIGHT // 3 + HEIGHT // 3 - SPACE), CROSS_WIDTH)\n\n# Check for a win\ndef check_win():\n    global game_over\n    # Check rows\n    for row in range(3):\n        if board[row][0] == board[row][1] == board[row][2] != '':\n            pygame.draw.line(screen, (0, 255, 0), (0, row * HEIGHT // 3 + HEIGHT // 6), (WIDTH, row * HEIGHT // 3 + HEIGHT // 6), LINE_WIDTH)\n            game_over = True\n            return board[row][0]\n    \n    # Check columns\n    for col in range(3):\n        if board[0][col] == board[1][col] == board[2][col] != '':\n            pygame.draw.line(screen, (0, 255, 0), (col * WIDTH // 3 + WIDTH // 6, 0), (col * WIDTH // 3 + WIDTH // 6, HEIGHT), LINE_WIDTH)\n            game_over = True\n            return board[0][col]\n    \n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != '':\n        pygame.draw.line(screen, (0, 255, 0), (0, 0), (WIDTH, HEIGHT), LINE_WIDTH)\n        game_over = True\n        return board[0][0]\n    \n    if board[0][2] == board[1][1] == board[2][0] != '':\n        pygame.draw.line(screen, (0, 255, 0), (WIDTH, 0), (0, HEIGHT), LINE_WIDTH)\n        game_over = True\n        return board[0][2]\n    \n    # Check for tie\n    if all(board[row][col] != '' for row in range(3) for col in range(3)):\n        game_over = True\n        return 'Tie'\n    \n    return None\n\n# Main game loop\ndef main():\n    global player, game_over\n    draw_board()\n    \n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:\n                    board[:] = [['' for _ in range(3)] for _ in range(3)]\n                    player = 'O'\n                    game_over = False\n                    draw_board()\n\n            if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n                mouseX = event.pos[0]\n                mouseY = event.pos[1]\n\n                clicked_row = mouseY // (HEIGHT // 3)\n                clicked_col = mouseX // (WIDTH // 3)\n\n                if board[clicked_row][clicked_col] == '':\n                    board[clicked_row][clicked_col] = player\n                    player = 'X' if player == 'O' else 'O'\n                    draw_marks()\n                    winner = check_win()\n                    if winner:\n                        print(f\"{winner} wins!\" if winner != 'Tie' else \"It's a Tie!\")\n        \n        pygame.display.update()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 0 positional arguments but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_WIDTH = 15\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH\nSPACE = CELL_SIZE // 4\n\n# Colors\nBACKGROUND_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Game variables\nboard = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = 'X'  # 'X' for Player 1 and 'O' for Player 2\ngame_over = False\n\n# Initialize the window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\ndef draw_lines():\n    # Draw horizontal lines\n    pygame.draw.line(screen, LINE_COLOR, (0, CELL_SIZE), (WINDOW_SIZE, CELL_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * CELL_SIZE), (WINDOW_SIZE, 2 * CELL_SIZE), LINE_WIDTH)\n    \n    # Draw vertical lines\n    pygame.draw.line(screen, LINE_COLOR, (CELL_SIZE, 0), (CELL_SIZE, WINDOW_SIZE), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (2 * CELL_SIZE, 0), (2 * CELL_SIZE, WINDOW_SIZE), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, \n                                 (col * CELL_SIZE + SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), \n                                 (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + SPACE), \n                                 CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, \n                                 (col * CELL_SIZE + SPACE, row * CELL_SIZE + SPACE), \n                                 (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), \n                                 CROSS_WIDTH)\n            elif board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, \n                                   (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), \n                                   CIRCLE_RADIUS, LINE_WIDTH)\n\ndef check_winner():\n    global game_over\n    # Check rows and columns\n    for i in range(GRID_SIZE):\n        if board[i][0] == board[i][1] == board[i][2] != None:\n            pygame.draw.line(screen, (255, 0, 0), (0, i * CELL_SIZE + CELL_SIZE // 2), (WINDOW_SIZE, i * CELL_SIZE + CELL_SIZE // 2), LINE_WIDTH)\n            game_over = True\n            return board[i][0]\n        if board[0][i] == board[1][i] == board[2][i] != None:\n            pygame.draw.line(screen, (255, 0, 0), (i * CELL_SIZE + CELL_SIZE // 2, 0), (i * CELL_SIZE + CELL_SIZE // 2, WINDOW_SIZE), LINE_WIDTH)\n            game_over = True\n            return board[0][i]\n\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != None:\n        pygame.draw.line(screen, (255, 0, 0), (0, 0), (WINDOW_SIZE, WINDOW_SIZE), LINE_WIDTH)\n        game_over = True\n        return board[0][0]\n\n    if board[0][2] == board[1][1] == board[2][0] != None:\n        pygame.draw.line(screen, (255, 0, 0), (WINDOW_SIZE, 0), (0, WINDOW_SIZE), LINE_WIDTH)\n        game_over = True\n        return board[0][2]\n\n    return None\n\ndef check_tie():\n    for row in board:\n        if None in row:\n            return False\n    return True\n\ndef restart_game():\n    global board, current_player, game_over\n    board = [[None for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = 'X'\n    game_over = False\n    screen.fill(BACKGROUND_COLOR)\n    draw_lines()\n    draw_marks()\n\n# Main game loop\ndef main():\n    screen.fill(BACKGROUND_COLOR)\n    draw_lines()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n                mouseX = event.pos[0]\n                mouseY = event.pos[1]\n\n                clicked_row = mouseY // CELL_SIZE\n                clicked_col = mouseX // CELL_SIZE\n\n                if board[clicked_row][clicked_col] is None:\n                    board[clicked_row][clicked_col] = current_player\n                    winner = check_winner()\n                    if winner:\n                        print(f\"Player {winner} wins!\")\n                    if check_tie() and not game_over:\n                        print(\"It's a tie!\")\n                    current_player = 'O' if current_player == 'X' else 'X'\n                    draw_marks()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:\n                    restart_game()\n\n        pygame.display.update()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (240, 240, 240)\nCROSS_COLOR = (240, 240, 240)\n\nWIDTH = 600\nHEIGHT = 600\nGRID_SIZE = 3\nSQUARE_SIZE = WIDTH // GRID_SIZE\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\n# Create the grid\ngrid = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\nplayer_turn = 'O'  # O starts first\ngame_over = False\n\n# Winning combinations\nwinning_combinations = [\n    [(0, 0), (0, 1), (0, 2)],\n    [(1, 0), (1, 1), (1, 2)],\n    [(2, 0), (2, 1), (2, 2)],\n    [(0, 0), (1, 0), (2, 0)],\n    [(0, 1), (1, 1), (2, 1)],\n    [(0, 2), (1, 2), (2, 2)],\n    [(0, 0), (1, 1), (2, 2)],\n    [(0, 2), (1, 1), (2, 0)],\n]\n\n# Function to draw the grid\ndef draw_grid():\n    for i in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (0, i * SQUARE_SIZE), (WIDTH, i * SQUARE_SIZE), 5)\n        pygame.draw.line(screen, LINE_COLOR, (i * SQUARE_SIZE, 0), (i * SQUARE_SIZE, HEIGHT), 5)\n\n# Function to draw the marks\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if grid[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 3, 15)\n            elif grid[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + 15, row * SQUARE_SIZE + 15), (col * SQUARE_SIZE + SQUARE_SIZE - 15, row * SQUARE_SIZE + SQUARE_SIZE - 15), 15)\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SQUARE_SIZE - 15, row * SQUARE_SIZE + 15), (col * SQUARE_SIZE + 15, row * SQUARE_SIZE + SQUARE_SIZE - 15), 15)\n\n# Function to check for a win\ndef check_win():\n    for combo in winning_combinations:\n        if grid[combo[0][0]][combo[0][1]] == grid[combo[1][0]][combo[1][1]] == grid[combo[2][0]][combo[2][1]] != '':\n            return grid[combo[0][0]][combo[0][1]], combo\n    return None, None\n\n# Function to reset the game\ndef reset_game():\n    global grid, player_turn, game_over\n    grid = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    player_turn = 'O'\n    game_over = False\n\n# Main game loop\nwhile True:\n    screen.fill(WHITE)\n    draw_grid()\n    draw_marks()\n\n    if game_over:\n        winner, winning_combo = check_win()\n        if winner:\n            print(f\"Player {winner} wins!\")\n            pygame.display.set_caption(f\"Player {winner} wins! Press R to restart.\")\n            pygame.draw.line(screen, LINE_COLOR, (winning_combo[0][1] * SQUARE_SIZE + SQUARE_SIZE // 2, winning_combo[0][0] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                             (winning_combo[2][1] * SQUARE_SIZE + SQUARE_SIZE // 2, winning_combo[2][0] * SQUARE_SIZE + SQUARE_SIZE // 2), 15)\n        else:\n            print(\"It's a tie!\")\n            pygame.display.set_caption(\"It's a tie! Press R to restart.\")\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                reset_game()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0]\n            mouseY = event.pos[1]\n            clicked_row = mouseY // SQUARE_SIZE\n            clicked_col = mouseX // SQUARE_SIZE\n\n            if grid[clicked_row][clicked_col] == '':\n                grid[clicked_row][clicked_col] = player_turn\n                player_turn = 'X' if player_turn == 'O' else 'O'\n\n            winner, _ = check_win()\n            if winner:\n                game_over = True\n\n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Logic error: check_win() takes 0 positional arguments but 2 were given"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_WIDTH = 15\nBOARD_ROWS = 3\nBOARD_COLS = 3\nSQUARE_SIZE = WIDTH // BOARD_COLS\nCIRCLE_RADIUS = SQUARE_SIZE // 3\nCROSS_WIDTH = 25\nSPACE = SQUARE_SIZE // 4\n\n# Colors\nBG_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Initialize the game\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic Tac Toe\")\nscreen.fill(BG_COLOR)\n\n# Game state\nboard = [[None for _ in range(BOARD_COLS)] for _ in range(BOARD_ROWS)]\nplayer = 1  # Player 1 is circle, Player 2 is cross\ngame_over = False\n\n# Draw the grid\ndef draw_lines():\n    pygame.draw.line(screen, LINE_COLOR, (0, SQUARE_SIZE), (WIDTH, SQUARE_SIZE), LINE_WIDTH)  # Horizontal line\n    pygame.draw.line(screen, LINE_COLOR, (0, 2 * SQUARE_SIZE), (WIDTH, 2 * SQUARE_SIZE), LINE_WIDTH)  # Horizontal line\n    pygame.draw.line(screen, LINE_COLOR, (SQUARE_SIZE, 0), (SQUARE_SIZE, HEIGHT), LINE_WIDTH)  # Vertical line\n    pygame.draw.line(screen, LINE_COLOR, (2 * SQUARE_SIZE, 0), (2 * SQUARE_SIZE, HEIGHT), LINE_WIDTH)  # Vertical line\n\n# Draw marks\ndef draw_marks():\n    for row in range(BOARD_ROWS):\n        for col in range(BOARD_COLS):\n            if board[row][col] == 1:\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2), CIRCLE_RADIUS)\n            elif board[row][col] == 2:\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * SQUARE_SIZE + SPACE, row * SQUARE_SIZE + SPACE), (col * SQUARE_SIZE + SQUARE_SIZE - SPACE, row * SQUARE_SIZE + SQUARE_SIZE - SPACE), CROSS_WIDTH)\n\n# Check for a win\ndef check_winner():\n    global game_over\n    # Check rows\n    for row in range(BOARD_ROWS):\n        if board[row][0] == board[row][1] == board[row][2] and board[row][0] is not None:\n            pygame.draw.line(screen, (255, 0, 0), (0, row * SQUARE_SIZE + SQUARE_SIZE // 2), (WIDTH, row * SQUARE_SIZE + SQUARE_SIZE // 2), LINE_WIDTH)\n            game_over = True\n\n    # Check columns\n    for col in range(BOARD_COLS):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] is not None:\n            pygame.draw.line(screen, (255, 0, 0), (col * SQUARE_SIZE + SQUARE_SIZE // 2, 0), (col * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT), LINE_WIDTH)\n            game_over = True\n\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] is not None:\n        pygame.draw.line(screen, (255, 0, 0), (0, 0), (WIDTH, HEIGHT), LINE_WIDTH)\n        game_over = True\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] is not None:\n        pygame.draw.line(screen, (255, 0, 0), (WIDTH, 0), (0, HEIGHT), LINE_WIDTH)\n        game_over = True\n\n    # Check for tie\n    if all(board[row][col] is not None for row in range(BOARD_ROWS) for col in range(BOARD_COLS)):\n        game_over = True\n\n# Restart the game\ndef reset_game():\n    global board, player, game_over\n    board = [[None for _ in range(BOARD_COLS)] for _ in range(BOARD_ROWS)]\n    player = 1\n    game_over = False\n    screen.fill(BG_COLOR)\n    draw_lines()\n\n# Game loop\ndraw_lines()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0] // SQUARE_SIZE\n            mouseY = event.pos[1] // SQUARE_SIZE\n            \n            if board[mouseY][mouseX] is None:\n                board[mouseY][mouseX] = player\n                check_winner()\n                player = 2 if player == 1 else 1\n                draw_marks()\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                reset_game()\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 3\nCELL_SIZE = WINDOW_SIZE // GRID_SIZE\nLINE_WIDTH = 15\nCIRCLE_RADIUS = CELL_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH\nSPACE = CELL_SIZE // 5\n\n# Colors\nBACKGROUND_COLOR = (28, 170, 156)\nLINE_COLOR = (23, 145, 135)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\n\n# Create the window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Tic-Tac-Toe\")\n\n# Game variables\nboard = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\ncurrent_player = 'O'  # O starts first\ngame_over = False\nwinner = None\n\n\ndef draw_board():\n    # Draw the grid lines\n    screen.fill(BACKGROUND_COLOR)\n    for x in range(1, GRID_SIZE):\n        pygame.draw.line(screen, LINE_COLOR, (x * CELL_SIZE, 0), (x * CELL_SIZE, WINDOW_SIZE), LINE_WIDTH)\n        pygame.draw.line(screen, LINE_COLOR, (0, x * CELL_SIZE), (WINDOW_SIZE, x * CELL_SIZE), LINE_WIDTH)\n\n\ndef draw_marks():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            if board[row][col] == 'O':\n                pygame.draw.circle(screen, CIRCLE_COLOR, (col * CELL_SIZE + CELL_SIZE // 2, row * CELL_SIZE + CELL_SIZE // 2), CIRCLE_RADIUS, CROSS_WIDTH)\n            elif board[row][col] == 'X':\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (col * CELL_SIZE + SPACE, row * CELL_SIZE + SPACE), (col * CELL_SIZE + CELL_SIZE - SPACE, row * CELL_SIZE + CELL_SIZE - SPACE), CROSS_WIDTH)\n\n\ndef check_winner():\n    global winner\n    # Check rows, columns, and diagonals for a winner\n    for row in range(GRID_SIZE):\n        if board[row][0] == board[row][1] == board[row][2] != '':\n            winner = board[row][0]\n            pygame.draw.line(screen, (255, 0, 0), (0, row * CELL_SIZE + CELL_SIZE // 2), (WINDOW_SIZE, row * CELL_SIZE + CELL_SIZE // 2), LINE_WIDTH)\n            return True\n\n    for col in range(GRID_SIZE):\n        if board[0][col] == board[1][col] == board[2][col] != '':\n            winner = board[0][col]\n            pygame.draw.line(screen, (255, 0, 0), (col * CELL_SIZE + CELL_SIZE // 2, 0), (col * CELL_SIZE + CELL_SIZE // 2, WINDOW_SIZE), LINE_WIDTH)\n            return True\n\n    if board[0][0] == board[1][1] == board[2][2] != '':\n        winner = board[0][0]\n        pygame.draw.line(screen, (255, 0, 0), (0, 0), (WINDOW_SIZE, WINDOW_SIZE), LINE_WIDTH)\n        return True\n\n    if board[0][2] == board[1][1] == board[2][0] != '':\n        winner = board[0][2]\n        pygame.draw.line(screen, (255, 0, 0), (WINDOW_SIZE, 0), (0, WINDOW_SIZE), LINE_WIDTH)\n        return True\n\n    return False\n\n\ndef check_draw():\n    return all(cell != '' for row in board for cell in row)\n\n\ndef restart_game():\n    global board, current_player, game_over, winner\n    board = [['' for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]\n    current_player = 'O'\n    game_over = False\n    winner = None\n\n\n# Game loop\nwhile True:\n    draw_board()\n    draw_marks()\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouse_x, mouse_y = event.pos\n            clicked_row = mouse_y // CELL_SIZE\n            clicked_col = mouse_x // CELL_SIZE\n\n            if board[clicked_row][clicked_col] == '':\n                board[clicked_row][clicked_col] = current_player\n                if check_winner():\n                    game_over = True\n                elif check_draw():\n                    game_over = True\n                current_player = 'X' if current_player == 'O' else 'O'\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                restart_game()\n\n    pygame.display.flip()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\nimport numpy as np\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_COLOR = (0, 0, 0)\nCIRCLE_COLOR = (239, 231, 200)\nCROSS_COLOR = (66, 66, 66)\nBG_COLOR = (28, 170, 156)\nLINE_WIDTH = 15\nCIRCLE_RADIUS = 60\nCROSS_WIDTH = 25\nSPACE = 55\n\n# Create the window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic Tac Toe\")\n\n# Create the board\nboard = np.zeros((3, 3))\n\n# Function to draw the lines of the board\ndef draw_lines():\n    pygame.draw.line(screen, LINE_COLOR, (0, 200), (600, 200), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (0, 400), (600, 400), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (200, 0), (200, 600), LINE_WIDTH)\n    pygame.draw.line(screen, LINE_COLOR, (400, 0), (400, 600), LINE_WIDTH)\n\n# Function to draw marks (circles and crosses)\ndef draw_marks():\n    for r in range(3):\n        for c in range(3):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, CIRCLE_COLOR, (int(c * 200 + 100), int(r * 200 + 100)), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[r][c] == 2:\n                pygame.draw.line(screen, CROSS_COLOR, (c * 200 + SPACE, r * 200 + 200 - SPACE), (c * 200 + 200 - SPACE, r * 200 + SPACE), CROSS_WIDTH)\n                pygame.draw.line(screen, CROSS_COLOR, (c * 200 + SPACE, r * 200 + SPACE), (c * 200 + 200 - SPACE, r * 200 + 200 - SPACE), CROSS_WIDTH)\n\n# Function to check for a win\ndef check_winner():\n    # Check rows\n    for r in range(3):\n        if board[r][0] == board[r][1] == board[r][2] != 0:\n            pygame.draw.line(screen, (255, 0, 0), (0, r * 200 + 100), (600, r * 200 + 100), LINE_WIDTH)\n            return board[r][0]\n\n    # Check columns\n    for c in range(3):\n        if board[0][c] == board[1][c] == board[2][c] != 0:\n            pygame.draw.line(screen, (255, 0, 0), (c * 200 + 100, 0), (c * 200 + 100, 600), LINE_WIDTH)\n            return board[0][c]\n\n    # Check diagonals\n    if board[0][0] == board[1][1] == board[2][2] != 0:\n        pygame.draw.line(screen, (255, 0, 0), (0, 0), (600, 600), LINE_WIDTH)\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] != 0:\n        pygame.draw.line(screen, (255, 0, 0), (600, 0), (0, 600), LINE_WIDTH)\n        return board[0][2]\n\n    # Check for tie\n    if 0 not in board:\n        return -1\n\n    return 0\n\n# Function to restart the game\ndef restart_game():\n    global board, player\n    board = np.zeros((3, 3))\n    player = 1\n    screen.fill(BG_COLOR)\n    draw_lines()\n    draw_marks()\n\n# Main loop\nplayer = 1\ngame_over = False\nscreen.fill(BG_COLOR)\ndraw_lines()\n\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        \n        if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n            mouseX = event.pos[0] // 200\n            mouseY = event.pos[1] // 200\n            \n            if board[mouseY][mouseX] == 0:\n                board[mouseY][mouseX] = player\n                if check_winner() != 0:\n                    game_over = True\n                player = 2 if player == 1 else 1\n                draw_marks()\n\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:\n                restart_game()\n                game_over = False\n\n    pygame.display.update()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nLINE_WIDTH = 15\nBOARD_ROWS = 3\nBOARD_COLS = 3\nSQUARE_SIZE = WIDTH // BOARD_COLS\nCIRCLE_RADIUS = SQUARE_SIZE // 3\nCROSS_WIDTH = LINE_WIDTH // 3\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic-Tac-Toe\")\nscreen.fill(WHITE)\n\n# Global variables\nboard = [[0] * BOARD_COLS for _ in range(BOARD_ROWS)]\nplayer = 1  # Player 1 starts\ngame_over = False\n\ndef draw_board():\n    for row in range(1, BOARD_ROWS):\n        pygame.draw.line(screen, BLACK, (0, row * SQUARE_SIZE), (WIDTH, row * SQUARE_SIZE), LINE_WIDTH)\n        pygame.draw.line(screen, BLACK, (row * SQUARE_SIZE, 0), (row * SQUARE_SIZE, HEIGHT), LINE_WIDTH)\n\ndef draw_marks():\n    for row in range(BOARD_ROWS):\n        for col in range(BOARD_COLS):\n            if board[row][col] == 1:\n                pygame.draw.circle(screen, BLUE, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2), CIRCLE_RADIUS, LINE_WIDTH)\n            elif board[row][col] == 2:\n                pygame.draw.line(screen, RED, (col * SQUARE_SIZE + CROSS_WIDTH, row * SQUARE_SIZE + SQUARE_SIZE - CROSS_WIDTH), (col * SQUARE_SIZE + SQUARE_SIZE - CROSS_WIDTH, row * SQUARE_SIZE + CROSS_WIDTH), LINE_WIDTH)\n                pygame.draw.line(screen, RED, (col * SQUARE_SIZE + CROSS_WIDTH, row * SQUARE_SIZE + CROSS_WIDTH), (col * SQUARE_SIZE + SQUARE_SIZE - CROSS_WIDTH, row * SQUARE_SIZE + SQUARE_SIZE - CROSS_WIDTH), LINE_WIDTH)\n\ndef check_winner():\n    global game_over\n    # Check rows, columns and diagonals\n    for row in range(BOARD_ROWS):\n        if board[row][0] == board[row][1] == board[row][2] != 0:\n            draw_winning_line((0, row), (BOARD_COLS, row), board[row][0])\n            game_over = True\n\n    for col in range(BOARD_COLS):\n        if board[0][col] == board[1][col] == board[2][col] != 0:\n            draw_winning_line((col, 0), (col, BOARD_ROWS), board[0][col])\n            game_over = True\n\n    if board[0][0] == board[1][1] == board[2][2] != 0:\n        draw_winning_line((0, 0), (BOARD_COLS, BOARD_ROWS), board[0][0])\n        game_over = True\n\n    if board[0][2] == board[1][1] == board[2][0] != 0:\n        draw_winning_line((BOARD_COLS - 1, 0), (0, BOARD_ROWS), board[0][2])\n        game_over = True\n\n    if all(board[row][col] != 0 for row in range(BOARD_ROWS) for col in range(BOARD_COLS)) and not game_over:\n        print(\"It's a tie!\")\n        game_over = True\n\ndef draw_winning_line(start, end, player):\n    if player == 1:\n        color = BLUE\n    else:\n        color = RED\n    pygame.draw.line(screen, color, (start[0] * SQUARE_SIZE + SQUARE_SIZE // 2, start[1] * SQUARE_SIZE + SQUARE_SIZE // 2), (end[0] * SQUARE_SIZE + SQUARE_SIZE // 2, end[1] * SQUARE_SIZE + SQUARE_SIZE // 2), LINE_WIDTH)\n\ndef restart_game():\n    global board, player, game_over\n    board = [[0] * BOARD_COLS for _ in range(BOARD_ROWS)]\n    player = 1\n    game_over = False\n    screen.fill(WHITE)\n    draw_board()\n\ndef main():\n    global player, game_over\n    draw_board()\n    \n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r and game_over:\n                    restart_game()\n\n            if event.type == pygame.MOUSEBUTTONDOWN and not game_over:\n                mouseX = event.pos[0]\n                mouseY = event.pos[1]\n\n                clicked_row = mouseY // SQUARE_SIZE\n                clicked_col = mouseX // SQUARE_SIZE\n\n                if board[clicked_row][clicked_col] == 0:\n                    board[clicked_row][clicked_col] = player\n                    draw_marks()\n                    check_winner()\n                    player = 2 if player == 1 else 1\n\n        pygame.display.update()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing check_win function"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      }
    ]
  },
  "connect_four": {
    "openai": [
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWIDTH = 700\nHEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create screen object\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Create the game board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece in the specified column\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check valid location to drop piece\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in the specified column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Print the board (for debugging)\ndef print_board(board):\n    print(np.flip(board, 0))\n\n# Check for win conditions\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    pygame.display.update()\n\n# Main game function\ndef main():\n    board = create_board()\n    print_board(board)\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n    pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nWIDTH = 700\nHEIGHT = 600\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for a valid location\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for a win\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(screen, board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), int(SQUARESIZE / 2 - 5))\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), int(SQUARESIZE / 2 - 5))\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), int(SQUARESIZE / 2 - 5))\n\ndef main():\n    pygame.init()\n\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Connect Four\")\n    board = create_board()\n    draw_board(screen, board)\n    pygame.display.update()\n\n    game_over = False\n    turn = 0  # Player 1 starts\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), int(SQUARESIZE / 2 - 5))\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), int(SQUARESIZE / 2 - 5))\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                draw_board(screen, board)\n\n                turn += 1\n                turn = turn % 2\n\n                if game_over:\n                    pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, HEIGHT))\n                    font = pygame.font.SysFont(\"monospace\", 75)\n                    label = font.render(\"Game Over\", 1, (255, 255, 255))\n                    screen.blit(label, (WIDTH // 2 - 200, HEIGHT // 2 - 50))\n                    pygame.display.update()\n                    pygame.time.wait(3000)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWINDOW_WIDTH = 700\nWINDOW_HEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the game board\ndef create_board():\n    board = np.zeros((ROW_COUNT, COLUMN_COUNT))\n    return board\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check if the column is valid\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for winning move\ndef winning_move(board, piece):\n    # Check horizontal\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), WINDOW_HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), WINDOW_HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n# Initialize the game\nboard = create_board()\ngame_over = False\nturn = 0\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\ndraw_board(board)\npygame.display.update()\n\n# Main game loop\nwhile not game_over:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()\n        \n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        label = pygame.font.Font(None, 64).render(\"Player 1 wins!\", True, RED)\n                        screen.blit(label, (100, 10))\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        label = pygame.font.Font(None, 64).render(\"Player 2 wins!\", True, YELLOW)\n                        screen.blit(label, (100, 10))\n                        game_over = True\n\n            draw_board(board)\n\n            turn += 1\n            turn = turn % 2\n\n            if game_over:\n                pygame.time.wait(3000)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the screen\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\ndef print_board(board):\n    print(np.flip(board, 0))\n\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n    pygame.display.update()\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game_over = True\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print_board(board)\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print_board(board)\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n                if game_over:\n                    pygame.time.wait(3000)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWINDOW_WIDTH = 700\nWINDOW_HEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the game window\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Function to create an empty board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Function to drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Function to get the next open row in a column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT-1, -1, -1):\n        if board[r][col] == 0:\n            return r\n\n# Function to check for win conditions\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c+1] == piece and board[r][c+2] == piece and board[r][c+3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c] == piece and board[r+2][c] == piece and board[r+3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c+1] == piece and board[r+2][c+2] == piece and board[r+3][c+3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r-1][c+1] == piece and board[r-2][c+2] == piece and board[r-3][c+3] == piece:\n                return True\n\n# Function to draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    pygame.display.update()\n\n# Main function to run the game\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLUE, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLUE, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if board[ROW_COUNT - 1][col] == 0:  # Check if column is valid\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"PLAYER 1 WINS!\")\n                            game_over = True\n\n                else:  # Ask for Player 2 Input\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if board[ROW_COUNT - 1][col] == 0:  # Check if column is valid\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"PLAYER 2 WINS!\")\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2  # Switch turns\n\n    # End the game\n    pygame.quit()\n    sys.exit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Initialize the game\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\nfont = pygame.font.SysFont(\"monospace\", 75)\n\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\ndef print_board(board):\n    print(np.flip(board, 0))\n\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n    pygame.display.update()\n\n# Main game loop\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n    \n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            \n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                \n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            label = font.render(\"Player 1 wins!\", 1, RED)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n                \n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            label = font.render(\"Player 2 wins!\", 1, YELLOW)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n                if game_over:\n                    pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import numpy as np\nimport pygame\nimport sys\n\n# Constants\nROWS = 6\nCOLS = 7\nWIDTH = 700\nHEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the game board\ndef create_board():\n    return np.zeros((ROWS, COLS))\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for valid move\ndef is_valid_location(board, col):\n    return board[ROWS-1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROWS):\n        if board[r][col] == 0:\n            return r\n\n# Print the board (for debugging)\ndef print_board(board):\n    print(np.flip(board, 0))\n\n# Check win conditions\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLS - 3):\n        for r in range(ROWS):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLS):\n        for r in range(ROWS - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLS - 3):\n        for r in range(ROWS - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLS - 3):\n        for r in range(3, ROWS):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the game board\ndef draw_board(board):\n    for c in range(COLS):\n        for r in range(ROWS):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n\n    for c in range(COLS):\n        for r in range(ROWS):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n    \n    pygame.display.update()\n\n# Main game function\ndef main():\n    board = create_board()\n    print_board(board)\n    game_over = False\n    turn = 0\n\n    # Set up the Pygame window\n    global screen\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    draw_board(board)\n    \n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                \n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n                else:\n                    # Ask for Player 2 Input\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2  # Switch turns\n\n        if game_over:\n            pygame.time.wait(3000)  # Wait before closing\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWIDTH = 700\nHEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\ndef print_board(board):\n    print(np.flip(board, 0))\n\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n    pygame.display.update()\n\n# Initialize Pygame\npygame.init()\n\n# Create screen\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Game variables\nboard = create_board()\ngame_over = False\nturn = 0\n\ndraw_board(board)\n\n# Game loop\nwhile not game_over:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = int(posx // SQUARESIZE)\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        print(\"Player 1 wins!\")\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = int(posx // SQUARESIZE)\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        print(\"Player 2 wins!\")\n                        game_over = True\n\n            print_board(board)\n            draw_board(board)\n\n            turn += 1\n            turn = turn % 2\n\n    if game_over:\n        pygame.time.wait(3000)",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = ROW_COUNT * SQUARESIZE + SQUARESIZE\nSIZE = (WIDTH, HEIGHT)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop piece\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check valid location\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get next open row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for winning move\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c+1] == piece and board[r][c+2] == piece and board[r][c+3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c] == piece and board[r+2][c] == piece and board[r+3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c+1] == piece and board[r+2][c+2] == piece and board[r+3][c+3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r-1][c+1] == piece and board[r-2][c+2] == piece and board[r-3][c+3] == piece:\n                return True\n\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c*SQUARESIZE + SQUARESIZE//2, r*SQUARESIZE + SQUARESIZE + SQUARESIZE//2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c*SQUARESIZE + SQUARESIZE//2, (ROW_COUNT-r-1)*SQUARESIZE + SQUARESIZE + SQUARESIZE//2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c*SQUARESIZE + SQUARESIZE//2, (ROW_COUNT-r-1)*SQUARESIZE + SQUARESIZE + SQUARESIZE//2), RADIUS)\n    pygame.display.update()\n\n# Initialize the game\npygame.init()\nscreen = pygame.display.set_mode(SIZE)\npygame.display.set_caption(\"Connect Four\")\nboard = create_board()\ndraw_board(board)\ngame_over = False\nturn = 0\n\n# Main game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        \n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        label = myfont.render(\"Player 1 wins!!\", 1, RED)\n                        screen.blit(label, (40, 10))\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        label = myfont.render(\"Player 2 wins!!\", 1, YELLOW)\n                        screen.blit(label, (40, 10))\n                        game_over = True\n\n            draw_board(board)\n\n            turn += 1\n            turn = turn % 2\n\n            if game_over:\n                pygame.time.wait(3000)",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the board\ndef create_board():\n    board = np.zeros((ROW_COUNT, COLUMN_COUNT))\n    return board\n\n# Drop a piece\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Valid move check\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get next open row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Winning move check\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    pygame.display.update()\n\n# Main game function\ndef main():\n    global screen\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Connect Four\")\n\n    board = create_board()\n    draw_board(board)\n    game_over = False\n    turn = 0\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            \n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n        if game_over:\n            pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Create an empty board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check valid move\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get next available row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Winning move check\ndef winning_move(board, piece):\n    # Check horizontal\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    pygame.display.update()\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\nboard = create_board()\ngame_over = False\nturn = 0\n\n# Draw initial board\ndraw_board(board)\n\n# Game loop\nwhile not game_over:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            game_over = True\n\n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        print(\"Player 1 wins!\")\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        print(\"Player 2 wins!\")\n                        game_over = True\n\n            draw_board(board)\n\n            # Switch turns\n            turn += 1\n            turn = turn % 2\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import numpy as np\nimport pygame\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWIDTH = 700\nHEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for valid move\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get the next available row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for winning move\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n\n# Initialize pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\ngame_over = False\nboard = create_board()\ndraw_board(board)\npygame.display.update()\n\n# Game loop\nturn = 0\nwhile not game_over:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        print(\"Player 1 wins!\")\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        print(\"Player 2 wins!\")\n                        game_over = True\n\n            draw_board(board)\n\n            turn += 1\n            turn = turn % 2\n\n    if game_over:\n        pygame.time.wait(3000)",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the board\ndef create_board():\n    board = np.zeros((ROW_COUNT, COLUMN_COUNT))\n    return board\n\n# Drop a piece\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for valid moves\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Print the board\ndef print_board(board):\n    print(np.flip(board, 0))\n\n# Check for a win\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n    pygame.display.update()\n\n# Initialize game\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\ndraw_board(create_board())\ngame_over = False\n\nboard = create_board()\nturn = 0\n\nwhile not game_over:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            game_over = True\n\n        if event.type == pygame.MOUSEMOTION:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            posx = event.pos[0]\n            if turn == 0:\n                pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n            else:\n                pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n        pygame.display.update()\n\n        if event.type == pygame.MOUSEBUTTONDOWN:\n            pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n            # Ask for Player 1 Input\n            if turn == 0:\n                posx = event.pos[0]\n                col = int(posx // SQUARESIZE)\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1)\n\n                    if winning_move(board, 1):\n                        print(\"Player 1 wins!\")\n                        game_over = True\n\n            # Ask for Player 2 Input\n            else:\n                posx = event.pos[0]\n                col = int(posx // SQUARESIZE)\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 2)\n\n                    if winning_move(board, 2):\n                        print(\"Player 2 wins!\")\n                        game_over = True\n\n            print_board(board)\n            draw_board(board)\n\n            turn += 1\n            turn = turn % 2\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import numpy as np\nimport pygame\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\nfont = pygame.font.SysFont(\"monospace\", 75)\n\n# Create a board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for valid location\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in a column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for winning move\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the game board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, HEIGHT - (r * SQUARESIZE + SQUARESIZE // 2)), RADIUS)\n    pygame.display.update()\n\n# Main game loop\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLUE, (0, 0, WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            label = font.render(\"Player 1 Wins!!\", True, RED)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            label = font.render(\"Player 2 Wins!!\", True, YELLOW)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n        if game_over:\n            pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport numpy as np\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWINDOW_WIDTH = 700\nWINDOW_HEIGHT = 600\nRADIUS = 40\nSQUARESIZE = 100\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption('Connect Four')\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check if the column is valid\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for win\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLUE, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE + RADIUS // 2), RADIUS)\n            \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE + RADIUS // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE + RADIUS // 2), RADIUS)\n    pygame.display.update()\n\n# Main function\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n                \n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWINDOW_WIDTH = 700\nWINDOW_HEIGHT = 600\nSQUARESIZE = 100\n\n# RGB colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the game window\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop the piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check if a column is valid\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get the next available row in a column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Print the board (for debugging purposes)\ndef print_board(board):\n    print(np.flip(board, 0))\n\n# Check for a win\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c+1] == piece and board[r][c+2] == piece and board[r][c+3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c] == piece and board[r+2][c] == piece and board[r+3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r-1][c+1] == piece and board[r-2][c+2] == piece and board[r-3][c+3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT-3):\n        for r in range(ROW_COUNT-3):\n            if board[r][c] == piece and board[r+1][c+1] == piece and board[r+2][c+2] == piece and board[r+3][c+3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c*SQUARESIZE, r*SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c*SQUARESIZE + SQUARESIZE/2), int(r*SQUARESIZE + SQUARESIZE + SQUARESIZE/2)), int(SQUARESIZE/2 - 5))\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c*SQUARESIZE + SQUARESIZE/2), int((ROW_COUNT - r - 1)*SQUARESIZE + SQUARESIZE + SQUARESIZE/2)), int(SQUARESIZE/2 - 5))\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c*SQUARESIZE + SQUARESIZE/2), int((ROW_COUNT - r - 1)*SQUARESIZE + SQUARESIZE + SQUARESIZE/2)), int(SQUARESIZE/2 - 5))\n    pygame.display.update()\n\n# Main game loop\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0  # Player 1 starts\n\n    draw_board(board)\n    \n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            \n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE/2)), int(SQUARESIZE/2 - 5))\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE/2)), int(SQUARESIZE/2 - 5))\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2  # Switch turns\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import numpy as np\nimport pygame\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWINDOW_WIDTH = 700\nWINDOW_HEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the game window\nsize = (WINDOW_WIDTH, WINDOW_HEIGHT)\nscreen = pygame.display.set_mode(size)\npygame.display.set_caption(\"Connect Four\")\n\n# Create game board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    \n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (ROW_COUNT - r - 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n    pygame.display.update()\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WINDOW_WIDTH, SQUARESIZE))\n                # Get the column clicked\n                posx = event.pos[0]\n                col = posx // SQUARESIZE\n\n                if is_valid_location(board, col):\n                    row = get_next_open_row(board, col)\n                    drop_piece(board, row, col, 1 if turn == 0 else 2)\n\n                    if winning_move(board, 1 if turn == 0 else 2):\n                        game_over = True\n                        print(f\"Player {1 if turn == 0 else 2} wins!\")\n\n                    draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n                if game_over:\n                    pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nWIDTH = 700\nHEIGHT = 600\nSQUARESIZE = 100\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the game window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop the piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check if the column is valid\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Print the board (for debugging)\ndef print_board(board):\n    print(np.flip(board, 0))\n\n# Winning condition check\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n# Main game function\ndef main():\n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n    pygame.display.update()\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            label = pygame.font.SysFont(\"monospace\", 75).render(\"Player 1 wins!\", 1, RED)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = int(posx // SQUARESIZE)\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            label = pygame.font.SysFont(\"monospace\", 75).render(\"Player 2 wins!\", 1, YELLOW)\n                            screen.blit(label, (40, 10))\n                            game_over = True\n\n                print_board(board)\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n                if game_over:\n                    pygame.time.wait(3000)\n\n    pygame.quit()\n\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import numpy as np\nimport pygame\nimport sys\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\nPLAYER1 = 1\nPLAYER2 = 2\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Create the board\ndef create_board():\n    board = np.zeros((ROW_COUNT, COLUMN_COUNT))\n    return board\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check if the column is valid\ndef is_valid_location(board, col):\n    return board[ROW_COUNT - 1][col] == 0\n\n# Get the next available row in the column\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for winning move\ndef winning_move(board, piece):\n    # Check horizontal locations for win\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations for win\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.circle(screen, BLACK, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            if board[r][c] == PLAYER1:\n                pygame.draw.circle(screen, RED, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n            elif board[r][c] == PLAYER2:\n                pygame.draw.circle(screen, YELLOW, (c * SQUARESIZE + SQUARESIZE // 2, (r + 1) * SQUARESIZE + SQUARESIZE // 2), RADIUS)\n    pygame.display.update()\n\n# Initialize pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Connect Four\")\n\n# Main game loop\ndef main():\n    board = create_board()\n    draw_board(board)\n    game_over = False\n    turn = 0\n    \n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            \n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, SQUARESIZE // 2), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, SQUARESIZE // 2), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                \n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, PLAYER1)\n\n                        if winning_move(board, PLAYER1):\n                            print(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, PLAYER2)\n\n                        if winning_move(board, PLAYER2):\n                            print(\"Player 2 wins!\")\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n        if game_over:\n            pygame.time.wait(3000)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport numpy as np\n\n# Constants\nROW_COUNT = 6\nCOLUMN_COUNT = 7\nSQUARESIZE = 100\nWIDTH = COLUMN_COUNT * SQUARESIZE\nHEIGHT = (ROW_COUNT + 1) * SQUARESIZE\nRADIUS = int(SQUARESIZE / 2 - 5)\n\n# Colors\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\nRED = (255, 0, 0)\nYELLOW = (255, 255, 0)\n\n# Initialize Pygame\npygame.init()\n\n# Create the board\ndef create_board():\n    return np.zeros((ROW_COUNT, COLUMN_COUNT))\n\n# Drop a piece in the board\ndef drop_piece(board, row, col, piece):\n    board[row][col] = piece\n\n# Check for valid location\ndef is_valid_location(board, col):\n    return board[ROW_COUNT-1][col] == 0\n\n# Get the next available row\ndef get_next_open_row(board, col):\n    for r in range(ROW_COUNT):\n        if board[r][col] == 0:\n            return r\n\n# Check for a win\ndef winning_move(board, piece):\n    # Check horizontal locations\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT):\n            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][c + 3] == piece:\n                return True\n\n    # Check vertical locations\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][c] == piece:\n                return True\n\n    # Check positively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(ROW_COUNT - 3):\n            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][c + 3] == piece:\n                return True\n\n    # Check negatively sloped diagonals\n    for c in range(COLUMN_COUNT - 3):\n        for r in range(3, ROW_COUNT):\n            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][c + 3] == piece:\n                return True\n\n# Draw the board\ndef draw_board(board):\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            pygame.draw.rect(screen, BLUE, (c * SQUARESIZE, r * SQUARESIZE + SQUARESIZE, SQUARESIZE, SQUARESIZE))\n            pygame.draw.circle(screen, BLACK, (int(c * SQUARESIZE + SQUARESIZE / 2), int(r * SQUARESIZE + SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n    for c in range(COLUMN_COUNT):\n        for r in range(ROW_COUNT):\n            if board[r][c] == 1:\n                pygame.draw.circle(screen, RED, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n            elif board[r][c] == 2:\n                pygame.draw.circle(screen, YELLOW, (int(c * SQUARESIZE + SQUARESIZE / 2), HEIGHT - int(r * SQUARESIZE + SQUARESIZE / 2)), RADIUS)\n\n# Display a message\ndef display_message(message):\n    font = pygame.font.SysFont(\"monospace\", 75)\n    label = font.render(message, 1, BLACK)\n    screen.blit(label, (WIDTH // 2 - label.get_width() // 2, HEIGHT // 2 - label.get_height() // 2))\n    pygame.display.update()\n    pygame.time.wait(3000)\n\n# Main game loop\ndef main():\n    global screen\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Connect Four\")\n    \n    board = create_board()\n    game_over = False\n    turn = 0\n\n    draw_board(board)\n    pygame.display.update()\n\n    while not game_over:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.MOUSEMOTION:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                posx = event.pos[0]\n                if turn == 0:\n                    pygame.draw.circle(screen, RED, (posx, int(SQUARESIZE / 2)), RADIUS)\n                else:\n                    pygame.draw.circle(screen, YELLOW, (posx, int(SQUARESIZE / 2)), RADIUS)\n            pygame.display.update()\n\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                pygame.draw.rect(screen, BLACK, (0, 0, WIDTH, SQUARESIZE))\n                \n                # Ask for Player 1 Input\n                if turn == 0:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 1)\n\n                        if winning_move(board, 1):\n                            draw_board(board)\n                            display_message(\"Player 1 wins!\")\n                            game_over = True\n\n                # Ask for Player 2 Input\n                else:\n                    posx = event.pos[0]\n                    col = posx // SQUARESIZE\n\n                    if is_valid_location(board, col):\n                        row = get_next_open_row(board, col)\n                        drop_piece(board, row, col, 2)\n\n                        if winning_move(board, 2):\n                            draw_board(board)\n                            display_message(\"Player 2 wins!\")\n                            game_over = True\n\n                draw_board(board)\n\n                turn += 1\n                turn = turn % 2\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      }
    ]
  },
  "snakes_and_ladders": {
    "openai": [
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize pygame\npygame.init()\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Load fonts\nfont = pygame.font.Font(None, 36)\n\n# Define colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            if square_number in LADDERS:\n                pygame.draw.rect(screen, GREEN, rect)\n            elif square_number in SNAKES:\n                pygame.draw.rect(screen, RED, rect)\n            else:\n                pygame.draw.rect(screen, WHITE, rect)\n            pygame.draw.rect(screen, BLUE, rect, 2)\n            text = font.render(str(square_number), True, BLUE)\n            text_rect = text.get_rect(center=rect.center)\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef main():\n    player_position = 1\n    game_over = False\n    dice_value = 0\n\n    while True:\n        screen.fill(WHITE)\n        draw_board()\n\n        if not game_over:\n            dice_value = 0\n            \n            for event in pygame.event.get():\n                if event.type == pygame.QUIT:\n                    pygame.quit()\n                    sys.exit()\n                if event.type == pygame.KEYDOWN:\n                    if event.key == pygame.K_SPACE:\n                        dice_value = roll_dice()\n                        player_position += dice_value\n                        if player_position > 100:\n                            player_position = 100\n                        # Check for ladders and snakes\n                        player_position = LADDERS.get(player_position, player_position)\n                        player_position = SNAKES.get(player_position, player_position)\n                        if player_position == 100:\n                            game_over = True\n                    elif event.key == pygame.K_r:\n                        player_position = 1\n                        game_over = False\n\n        # Draw the player\n        player_x = (player_position - 1) % BOARD_SIZE * SQUARE_SIZE + SQUARE_SIZE // 2\n        player_y = (BOARD_SIZE - 1 - (player_position - 1) // BOARD_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        pygame.draw.circle(screen, BLUE, (player_x, player_y), SQUARE_SIZE // 4)\n\n        # Display current position and dice value\n        position_text = font.render(f'Position: {player_position}', True, BLUE)\n        dice_text = font.render(f'Dice: {dice_value}', True, BLUE)\n        screen.blit(position_text, (10, 10))\n        screen.blit(dice_text, (10, 50))\n\n        if game_over:\n            win_text = font.render('You Win! Press R to Restart', True, BLUE)\n            screen.blit(win_text, (WINDOW_SIZE // 2 - win_text.get_width() // 2, WINDOW_SIZE // 2))\n\n        pygame.display.flip()\n        pygame.time.delay(100)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snakes and Ladders')\nfont = pygame.font.Font(None, 36)\n\ndef draw_board(player_position):\n    screen.fill(WHITE)\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            square_number = i * BOARD_SIZE + j + 1\n            rect = (j * SQUARE_SIZE, (BOARD_SIZE - 1 - i) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            pygame.draw.rect(screen, BLACK, rect, 1)\n            text = font.render(str(square_number), True, BLACK)\n            screen.blit(text, (j * SQUARE_SIZE + SQUARE_SIZE // 3, (BOARD_SIZE - 1 - i) * SQUARE_SIZE + SQUARE_SIZE // 3))\n\n    # Draw ladders\n    for start, end in LADDERS.items():\n        start_pos = ((start - 1) % BOARD_SIZE, BOARD_SIZE - 1 - (start - 1) // BOARD_SIZE)\n        end_pos = ((end - 1) % BOARD_SIZE, BOARD_SIZE - 1 - (end - 1) // BOARD_SIZE)\n        pygame.draw.line(screen, GREEN, (start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n    # Draw snakes\n    for start, end in SNAKES.items():\n        start_pos = ((start - 1) % BOARD_SIZE, BOARD_SIZE - 1 - (start - 1) // BOARD_SIZE)\n        end_pos = ((end - 1) % BOARD_SIZE, BOARD_SIZE - 1 - (end - 1) // BOARD_SIZE)\n        pygame.draw.line(screen, RED, (start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n    # Draw player\n    player_pos = ((player_position - 1) % BOARD_SIZE, BOARD_SIZE - 1 - (player_position - 1) // BOARD_SIZE)\n    pygame.draw.circle(screen, (0, 0, 255), (player_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2, player_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 4)\n\ndef main():\n    player_position = 1\n    dice_value = 0\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = random.randint(1, 6)\n                    if player_position + dice_value <= 100:\n                        player_position += dice_value\n                        # Check for ladders or snakes\n                        if player_position in LADDERS:\n                            player_position = LADDERS[player_position]\n                        elif player_position in SNAKES:\n                            player_position = SNAKES[player_position]\n                    if player_position == 100:\n                        game_over = True\n                elif event.key == pygame.K_r:\n                    player_position = 1\n                    dice_value = 0\n                    game_over = False\n\n        draw_board(player_position)\n\n        # Display current position and dice value\n        position_text = font.render(f'Position: {player_position}', True, BLACK)\n        dice_text = font.render(f'Dice: {dice_value}', True, BLACK)\n        screen.blit(position_text, (10, 10))\n        screen.blit(dice_text, (10, 50))\n\n        if game_over:\n            win_text = font.render('You Win! Press R to Restart', True, BLACK)\n            screen.blit(win_text, (WINDOW_SIZE // 4, WINDOW_SIZE // 2))\n\n        pygame.display.flip()\n\nif __name__ == '__main__':\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFONT_SIZE = 24\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Game variables\nplayer_pos = 1\ngame_over = False\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize the game window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Load font\nfont = pygame.font.Font(None, FONT_SIZE)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            color = WHITE if (row + col) % 2 == 0 else (200, 200, 200)\n            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=(col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef check_ladders_and_snakes(position):\n    if position in ladders:\n        return ladders[position]\n    elif position in snakes:\n        return snakes[position]\n    return position\n\ndef reset_game():\n    global player_pos, game_over\n    player_pos = 1\n    game_over = False\n\ndef main():\n    global player_pos, game_over\n    clock = pygame.time.Clock()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    roll = random.randint(1, 6)\n                    player_pos += roll\n                    if player_pos > 100:\n                        player_pos = 100  # Ensure player doesn't go past 100\n                    player_pos = check_ladders_and_snakes(player_pos)\n\n                    if player_pos == 100:\n                        game_over = True\n                if event.key == pygame.K_r:\n                    reset_game()\n\n        # Draw everything\n        screen.fill(BLACK)\n        draw_board()\n\n        # Draw the player\n        player_row = BOARD_SIZE - 1 - (player_pos - 1) // BOARD_SIZE\n        player_col = (player_pos - 1) % BOARD_SIZE\n        pygame.draw.circle(screen, BLUE, (player_col * SQUARE_SIZE + SQUARE_SIZE // 2, player_row * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 4)\n\n        # Display current position and dice value\n        pos_text = font.render(f\"Current Position: {player_pos}\", True, GREEN)\n        screen.blit(pos_text, (10, 10))\n\n        if game_over:\n            win_text = font.render(\"You Win! Press 'R' to Restart\", True, GREEN)\n            screen.blit(win_text, (WINDOW_SIZE // 2 - win_text.get_width() // 2, WINDOW_SIZE // 2))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Game variables\nplayer_position = 1\ndice_value = 0\ngame_over = False\n\n# Create the display\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = (BOARD_SIZE - row - 1) * SQUARE_SIZE  # Invert row for proper display\n            color = WHITE if (row + col) % 2 == 0 else BLACK\n            pygame.draw.rect(screen, color, (x, y, SQUARE_SIZE, SQUARE_SIZE))\n            # Draw number\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(square_number), True, BLACK if color == WHITE else WHITE)\n            text_rect = text.get_rect(center=(x + SQUARE_SIZE // 2, y + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef move_player(position):\n    # Check for ladders or snakes\n    if position in LADDERS:\n        return LADDERS[position]\n    elif position in SNAKES:\n        return SNAKES[position]\n    return position\n\ndef reset_game():\n    global player_position, dice_value, game_over\n    player_position = 1\n    dice_value = 0\n    game_over = False\n\ndef main():\n    global player_position, dice_value, game_over\n\n    clock = pygame.time.Clock()\n    \n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = random.randint(1, 6)\n                    next_position = player_position + dice_value\n                    if next_position <= 100:\n                        player_position = move_player(next_position)\n                    # Check for win condition\n                    if player_position == 100:\n                        game_over = True\n                if event.key == pygame.K_r:\n                    reset_game()\n\n        screen.fill(WHITE)\n        draw_board()\n        \n        # Draw player\n        player_x = (player_position - 1) % BOARD_SIZE * SQUARE_SIZE + SQUARE_SIZE // 2\n        player_y = (BOARD_SIZE - (player_position - 1) // BOARD_SIZE - 1) * SQUARE_SIZE + SQUARE_SIZE // 2\n        pygame.draw.circle(screen, GREEN if not game_over else RED, (player_x, player_y), SQUARE_SIZE // 4)\n        \n        # Draw dice value and current position\n        font = pygame.font.Font(None, 36)\n        dice_text = font.render(f'Dice: {dice_value}', True, BLACK)\n        pos_text = font.render(f'Position: {player_position}', True, BLACK)\n        screen.blit(dice_text, (10, 10))\n        screen.blit(pos_text, (10, 50))\n\n        if game_over:\n            win_text = font.render('You Win! Press R to Restart', True, BLACK)\n            screen.blit(win_text, (WINDOW_SIZE // 2 - win_text.get_width() // 2, WINDOW_SIZE // 2))\n\n        pygame.display.flip()\n        clock.tick(30)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFPS = 60\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Ladders and snakes mapping\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Game variables\nplayer_position = 1\n\ndef draw_board(screen):\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            if square_number in ladders:\n                pygame.draw.rect(screen, GREEN, rect)\n            elif square_number in snakes:\n                pygame.draw.rect(screen, RED, rect)\n            else:\n                pygame.draw.rect(screen, WHITE, rect)\n            pygame.draw.rect(screen, BLACK, rect, 1)  # Border\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=rect.center)\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef move_player(position, dice_value):\n    new_position = position + dice_value\n    if new_position > 100:\n        return position\n    # Check for ladders or snakes\n    if new_position in ladders:\n        new_position = ladders[new_position]\n    elif new_position in snakes:\n        new_position = snakes[new_position]\n    return new_position\n\ndef main():\n    global player_position\n\n    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption(\"Snakes and Ladders\")\n    clock = pygame.time.Clock()\n\n    running = True\n    while running:\n        screen.fill(BLACK)\n        draw_board(screen)\n\n        # Display player's current position\n        font = pygame.font.Font(None, 36)\n        position_text = font.render(f'Current Position: {player_position}', True, WHITE)\n        screen.blit(position_text, (10, 10))\n\n        # Handle events\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            \n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    dice_value = roll_dice()\n                    player_position = move_player(player_position, dice_value)\n                    if player_position == 100:\n                        print(\"You win!\")\n                elif event.key == pygame.K_r:\n                    player_position = 1  # Restart the game\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWINDOW_SIZE = 600\nGRID_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // GRID_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\nBOARD_SIZE = GRID_SIZE * GRID_SIZE\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Initialize pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\nclock = pygame.time.Clock()\n\n# Game variables\nplayer_pos = 1\ndice_value = 0\ngame_over = False\n\ndef draw_board():\n    for row in range(GRID_SIZE):\n        for col in range(GRID_SIZE):\n            square_num = (row * GRID_SIZE) + col + 1\n            x = col * SQUARE_SIZE\n            y = WINDOW_SIZE - (row + 1) * SQUARE_SIZE\n            pygame.draw.rect(screen, WHITE, (x, y, SQUARE_SIZE, SQUARE_SIZE))\n            pygame.draw.rect(screen, BLUE, (x, y, SQUARE_SIZE, SQUARE_SIZE), 2)\n            font = pygame.font.SysFont(None, 24)\n            text = font.render(str(square_num), True, WHITE)\n            screen.blit(text, (x + SQUARE_SIZE // 3, y + SQUARE_SIZE // 3))\n\n    # Draw ladders\n    for start, end in LADDERS.items():\n        start_x = ((start - 1) % GRID_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        start_y = WINDOW_SIZE - ((start - 1) // GRID_SIZE + 1) * SQUARE_SIZE + SQUARE_SIZE // 2\n        end_x = ((end - 1) % GRID_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        end_y = WINDOW_SIZE - ((end - 1) // GRID_SIZE + 1) * SQUARE_SIZE + SQUARE_SIZE // 2\n        pygame.draw.line(screen, GREEN, (start_x, start_y), (end_x, end_y), 5)\n\n    # Draw snakes\n    for start, end in SNAKES.items():\n        start_x = ((start - 1) % GRID_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        start_y = WINDOW_SIZE - ((start - 1) // GRID_SIZE + 1) * SQUARE_SIZE + SQUARE_SIZE // 2\n        end_x = ((end - 1) % GRID_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        end_y = WINDOW_SIZE - ((end - 1) // GRID_SIZE + 1) * SQUARE_SIZE + SQUARE_SIZE // 2\n        pygame.draw.line(screen, RED, (start_x, start_y), (end_x, end_y), 5)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef move_player(position, roll):\n    new_position = position + roll\n    if new_position > BOARD_SIZE:\n        return position  # Can't move beyond 100\n    if new_position in LADDERS:\n        return LADDERS[new_position]  # Move to the top of the ladder\n    if new_position in SNAKES:\n        return SNAKES[new_position]  # Move to the tail of the snake\n    return new_position\n\ndef main():\n    global player_pos, dice_value, game_over\n    while True:\n        screen.fill((0, 0, 0))\n        draw_board()\n        \n        if game_over:\n            font = pygame.font.SysFont(None, 48)\n            text = font.render(\"You Win! Press 'R' to restart\", True, WHITE)\n            screen.blit(text, (WINDOW_SIZE // 4, WINDOW_SIZE // 2))\n        else:\n            font = pygame.font.SysFont(None, 36)\n            text = font.render(f\"Current Position: {player_pos} Dice: {dice_value}\", True, WHITE)\n            screen.blit(text, (10, 10))\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_dice()\n                    player_pos = move_player(player_pos, dice_value)\n                    if player_pos == BOARD_SIZE:\n                        game_over = True\n                elif event.key == pygame.K_r:\n                    player_pos = 1\n                    dice_value = 0\n                    game_over = False\n\n        pygame.display.flip()\n        clock.tick(60)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_WIDTH, WINDOW_HEIGHT = 600, 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_WIDTH // BOARD_SIZE\nBACKGROUND_COLOR = (255, 255, 255)\nLINE_COLOR = (0, 0, 0)\nLADDER_COLOR = (0, 255, 0)\nSNAKE_COLOR = (255, 0, 0)\nTEXT_COLOR = (0, 0, 0)\nFONT_SIZE = 30\n\n# Ladder and snake mappings\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\ndef draw_board(screen):\n    # Draw the board with squares numbered from 1 to 100\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            num = BOARD_SIZE * (BOARD_SIZE - 1 - i) + (j + 1)\n            rect = pygame.Rect(j * SQUARE_SIZE, i * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            pygame.draw.rect(screen, BACKGROUND_COLOR, rect)\n            pygame.draw.rect(screen, LINE_COLOR, rect, 1)\n            font = pygame.font.Font(None, FONT_SIZE)\n            text = font.render(str(num), True, TEXT_COLOR)\n            text_rect = text.get_rect(center=rect.center)\n            screen.blit(text, text_rect)\n\n    # Draw ladders\n    for start, end in ladders.items():\n        start_pos = get_square_position(start)\n        end_pos = get_square_position(end)\n        pygame.draw.line(screen, LADDER_COLOR, start_pos, end_pos, 5)\n\n    # Draw snakes\n    for start, end in snakes.items():\n        start_pos = get_square_position(start)\n        end_pos = get_square_position(end)\n        pygame.draw.line(screen, SNAKE_COLOR, start_pos, end_pos, 5)\n\ndef get_square_position(square):\n    \"\"\"Get the top-left position of a square on the board.\"\"\"\n    row = BOARD_SIZE - (square - 1) // BOARD_SIZE - 1\n    col = (square - 1) % BOARD_SIZE\n    return (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2)\n\ndef roll_dice():\n    \"\"\"Roll a 6-sided die.\"\"\"\n    return random.randint(1, 6)\n\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    clock = pygame.time.Clock()\n\n    player_position = 1\n    dice_value = 0\n    game_over = False\n\n    while True:\n        screen.fill(BACKGROUND_COLOR)\n        draw_board(screen)\n\n        # Display current position and dice value\n        font = pygame.font.Font(None, FONT_SIZE)\n        pos_text = font.render(f\"Position: {player_position}\", True, TEXT_COLOR)\n        dice_text = font.render(f\"Dice: {dice_value}\", True, TEXT_COLOR)\n        screen.blit(pos_text, (10, 10))\n        screen.blit(dice_text, (10, 50))\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_dice()\n                    player_position += dice_value\n                    if player_position > 100:\n                        player_position = 100\n                    # Check for ladders and snakes\n                    if player_position in ladders:\n                        player_position = ladders[player_position]\n                    elif player_position in snakes:\n                        player_position = snakes[player_position]\n                    if player_position == 100:\n                        game_over = True\n                elif event.key == pygame.K_r:\n                    player_position = 1\n                    dice_value = 0\n                    game_over = False\n\n        # Show win message\n        if game_over:\n            win_text = font.render(\"You Win! Press 'R' to Restart\", True, TEXT_COLOR)\n            screen.blit(win_text, (WINDOW_WIDTH // 2 - 150, WINDOW_HEIGHT // 2))\n\n        pygame.display.flip()\n        clock.tick(60)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Initialize the screen\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Game Variables\nplayer_pos = 1\ndice_value = 0\nrunning = True\ngame_over = False\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = WINDOW_SIZE - (row + 1) * SQUARE_SIZE\n            color = WHITE\n            if square_number in LADDERS:\n                color = GREEN\n            elif square_number in SNAKES:\n                color = RED\n            pygame.draw.rect(screen, color, (x, y, SQUARE_SIZE, SQUARE_SIZE), 0)\n            pygame.draw.rect(screen, BLACK, (x, y, SQUARE_SIZE, SQUARE_SIZE), 2)\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=(x + SQUARE_SIZE // 2, y + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef check_ladders_and_snakes(position):\n    if position in LADDERS:\n        return LADDERS[position]\n    elif position in SNAKES:\n        return SNAKES[position]\n    return position\n\ndef reset_game():\n    global player_pos, dice_value, game_over\n    player_pos = 1\n    dice_value = 0\n    game_over = False\n\n# Main game loop\nwhile running:\n    screen.fill(BLACK)\n    draw_board()\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and not game_over:\n                dice_value = roll_dice()\n                player_pos += dice_value\n                if player_pos > 100:\n                    player_pos = 100\n                player_pos = check_ladders_and_snakes(player_pos)\n                if player_pos == 100:\n                    game_over = True\n            if event.key == pygame.K_r:\n                reset_game()\n\n    # Display current position and dice value\n    font = pygame.font.Font(None, 36)\n    position_text = font.render(f\"Position: {player_pos}\", True, WHITE)\n    dice_text = font.render(f\"Dice: {dice_value}\", True, WHITE)\n    screen.blit(position_text, (10, 10))\n    screen.blit(dice_text, (10, 50))\n\n    if game_over:\n        win_text = font.render(\"You Win! Press 'R' to Restart\", True, WHITE)\n        screen.blit(win_text, (150, 300))\n\n    pygame.display.flip()\n    pygame.time.delay(100)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Ladders and Snakes mappings\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\nclass Game:\n    def __init__(self):\n        pygame.init()\n        self.screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n        pygame.display.set_caption(\"Snakes and Ladders\")\n        self.clock = pygame.time.Clock()\n        self.player_position = 1\n        self.dice_value = 0\n        self.game_over = False\n\n    def draw_board(self):\n        for row in range(BOARD_SIZE):\n            for col in range(BOARD_SIZE):\n                square_number = row * BOARD_SIZE + col + 1\n                rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n                pygame.draw.rect(self.screen, WHITE, rect, 1)\n\n                # Draw square number\n                font = pygame.font.Font(None, 24)\n                text = font.render(str(square_number), True, BLACK)\n                text_rect = text.get_rect(center=rect.center)\n                self.screen.blit(text, text_rect)\n\n                # Draw ladders\n                if square_number in ladders:\n                    top = ladders[square_number]\n                    top_row = (top - 1) // BOARD_SIZE\n                    top_col = (top - 1) % BOARD_SIZE\n                    pygame.draw.line(self.screen, GREEN, rect.center, (top_col * SQUARE_SIZE + SQUARE_SIZE // 2, top_row * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n                # Draw snakes\n                if square_number in snakes:\n                    tail = snakes[square_number]\n                    tail_row = (tail - 1) // BOARD_SIZE\n                    tail_col = (tail - 1) % BOARD_SIZE\n                    pygame.draw.line(self.screen, RED, rect.center, (tail_col * SQUARE_SIZE + SQUARE_SIZE // 2, tail_row * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n    def roll_dice(self):\n        self.dice_value = random.randint(1, 6)\n        new_position = self.player_position + self.dice_value\n        if new_position <= 100:\n            self.player_position = new_position\n            # Check for ladders or snakes\n            if self.player_position in ladders:\n                self.player_position = ladders[self.player_position]\n            elif self.player_position in snakes:\n                self.player_position = snakes[self.player_position]\n\n    def reset_game(self):\n        self.player_position = 1\n        self.dice_value = 0\n        self.game_over = False\n\n    def run(self):\n        while True:\n            self.screen.fill(BLACK)\n            self.draw_board()\n\n            # Display current position and dice value\n            font = pygame.font.Font(None, 36)\n            position_text = font.render(f\"Position: {self.player_position}\", True, WHITE)\n            dice_text = font.render(f\"Dice: {self.dice_value}\", True, WHITE)\n            self.screen.blit(position_text, (10, 10))\n            self.screen.blit(dice_text, (10, 50))\n\n            if self.player_position == 100:\n                self.game_over = True\n                win_text = font.render(\"You Win! Press R to restart.\", True, BLUE)\n                self.screen.blit(win_text, (WINDOW_SIZE//2 - 150, WINDOW_SIZE//2))\n            else:\n                for event in pygame.event.get():\n                    if event.type == pygame.QUIT:\n                        pygame.quit()\n                        sys.exit()\n                    if event.type == pygame.KEYDOWN:\n                        if event.key == pygame.K_SPACE:\n                            self.roll_dice()\n                        elif event.key == pygame.K_r and self.game_over:\n                            self.reset_game()\n\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    game = Game()\n    game.run()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFONT_SIZE = 28\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Game variables\nplayer_pos = 1\ndice_value = 0\ngame_over = False\n\n# Create a window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Load font\nfont = pygame.font.Font(None, FONT_SIZE)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_num = row * BOARD_SIZE + col + 1\n            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            pygame.draw.rect(screen, WHITE, rect)\n            pygame.draw.rect(screen, BLACK, rect, 2)\n\n            # Draw the ladder and snake\n            if square_num in ladders:\n                pygame.draw.line(screen, GREEN, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE), \n                                 (col * SQUARE_SIZE + SQUARE_SIZE // 2, (row - 1) * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n            if square_num in snakes:\n                pygame.draw.line(screen, RED, (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE), \n                                 (col * SQUARE_SIZE + SQUARE_SIZE // 2, (row + 1) * SQUARE_SIZE - SQUARE_SIZE // 2), 5)\n\n            # Draw the square number\n            text = font.render(str(square_num), True, BLACK)\n            text_rect = text.get_rect(center=(col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef move_player(position, roll):\n    new_pos = position + roll\n    if new_pos > 100:\n        return position  # Can't move past 100\n    return ladders.get(new_pos, snakes.get(new_pos, new_pos))\n\ndef reset_game():\n    global player_pos, dice_value, game_over\n    player_pos = 1\n    dice_value = 0\n    game_over = False\n\n# Main game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and not game_over:\n                dice_value = roll_dice()\n                player_pos = move_player(player_pos, dice_value)\n                if player_pos == 100:\n                    game_over = True\n            elif event.key == pygame.K_r:\n                reset_game()\n\n    # Draw everything\n    screen.fill(BLACK)\n    draw_board()\n\n    # Draw the player\n    player_row = (player_pos - 1) // BOARD_SIZE\n    player_col = (player_pos - 1) % BOARD_SIZE\n    pygame.draw.circle(screen, GREEN, (player_col * SQUARE_SIZE + SQUARE_SIZE // 2, \n                                        player_row * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 3)\n\n    # Draw text\n    current_pos_text = font.render(f'Current Position: {player_pos}', True, WHITE)\n    dice_text = font.render(f'Dice Roll: {dice_value}', True, WHITE)\n    screen.blit(current_pos_text, (10, 10))\n    screen.blit(dice_text, (10, 40))\n\n    if game_over:\n        win_text = font.render('You Win! Press R to Restart', True, WHITE)\n        screen.blit(win_text, (WINDOW_SIZE // 2 - win_text.get_width() // 2, WINDOW_SIZE // 2))\n\n    pygame.display.flip()\n    clock.tick(FPS)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nSCREEN_WIDTH = 600\nSCREEN_HEIGHT = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = SCREEN_WIDTH // BOARD_SIZE\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Ladder and Snake mappings\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Setup the screen\nscreen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Font\nfont = pygame.font.SysFont(None, 48)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = SCREEN_HEIGHT - (row + 1) * SQUARE_SIZE\n            pygame.draw.rect(screen, WHITE, (x, y, SQUARE_SIZE, SQUARE_SIZE), 0)\n            pygame.draw.rect(screen, BLACK, (x, y, SQUARE_SIZE, SQUARE_SIZE), 2)\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=(x + SQUARE_SIZE // 2, y + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef draw_ladders_and_snakes():\n    for start, end in ladders.items():\n        start_pos = ((start - 1) % BOARD_SIZE, (start - 1) // BOARD_SIZE)\n        end_pos = ((end - 1) % BOARD_SIZE, (end - 1) // BOARD_SIZE)\n        pygame.draw.line(screen, GREEN, (start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2,\n                                           SCREEN_HEIGHT - (start_pos[1] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2,\n                          SCREEN_HEIGHT - (end_pos[1] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n    for start, end in snakes.items():\n        start_pos = ((start - 1) % BOARD_SIZE, (start - 1) // BOARD_SIZE)\n        end_pos = ((end - 1) % BOARD_SIZE, (end - 1) // BOARD_SIZE)\n        pygame.draw.line(screen, RED, (start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2,\n                                         SCREEN_HEIGHT - (start_pos[1] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2,\n                          SCREEN_HEIGHT - (end_pos[1] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\ndef main():\n    player_pos = 1\n    dice_value = 0\n    running = True\n    clock = pygame.time.Clock()\n\n    while running:\n        screen.fill(BLACK)\n        draw_board()\n        draw_ladders_and_snakes()\n\n        # Display current position and dice value\n        position_text = font.render(f\"Position: {player_pos}\", True, WHITE)\n        dice_text = font.render(f\"Dice: {dice_value}\", True, WHITE)\n        screen.blit(position_text, (20, 20))\n        screen.blit(dice_text, (20, 80))\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    dice_value = random.randint(1, 6)\n                    player_pos += dice_value\n                    if player_pos > 100:\n                        player_pos = 100  # Prevent going past the last square\n                    # Check for ladders or snakes\n                    if player_pos in ladders:\n                        player_pos = ladders[player_pos]\n                    elif player_pos in snakes:\n                        player_pos = snakes[player_pos]\n                    # Check for win\n                    if player_pos >= 100:\n                        print(\"You win!\")\n                elif event.key == pygame.K_r:\n                    player_pos = 1\n                    dice_value = 0\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\n\n# Colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Ladder and Snake Definitions\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Font\nfont = pygame.font.Font(None, 36)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            if square_number in ladders:\n                color = GREEN\n            elif square_number in snakes:\n                color = RED\n            else:\n                color = WHITE\n            \n            pygame.draw.rect(screen, color, rect)\n            pygame.draw.rect(screen, BLACK, rect, 2)\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=rect.center)\n            screen.blit(text, text_rect)\n\ndef roll_die():\n    return random.randint(1, 6)\n\ndef move_player(position, roll):\n    new_position = position + roll\n    if new_position > 100:\n        return position  # Can't move outside of the board\n\n    if new_position in ladders:\n        return ladders[new_position]\n    elif new_position in snakes:\n        return snakes[new_position]\n    return new_position\n\ndef main():\n    player_position = 1\n    game_over = False\n    clock = pygame.time.Clock()\n\n    while True:\n        screen.fill(WHITE)\n        draw_board()\n\n        # Display current position and dice value\n        position_text = font.render(f\"Current Position: {player_position}\", True, BLACK)\n        screen.blit(position_text, (10, 10))\n        \n        if game_over:\n            win_text = font.render(\"You Win! Press 'R' to Restart\", True, BLACK)\n            screen.blit(win_text, (10, 50))\n        else:\n            dice_value = None\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_die()\n                    player_position = move_player(player_position, dice_value)\n                    if player_position == 100:\n                        game_over = True\n                if event.key == pygame.K_r:\n                    player_position = 1\n                    game_over = False\n\n        if dice_value is not None and not game_over:\n            dice_text = font.render(f\"Dice Rolled: {dice_value}\", True, BLACK)\n            screen.blit(dice_text, (10, 100))\n\n        pygame.display.flip()\n        clock.tick(30)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFPS = 30\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\nclock = pygame.time.Clock()\n\n# Colors\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\nBLACK = (0, 0, 0)\n\n# Game Variables\nplayer_pos = 1\ndice_value = 0\ngame_over = False\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = (BOARD_SIZE - 1 - row) * SQUARE_SIZE\n            pygame.draw.rect(screen, WHITE, (x, y, SQUARE_SIZE, SQUARE_SIZE))\n            pygame.draw.rect(screen, BLACK, (x, y, SQUARE_SIZE, SQUARE_SIZE), 3)\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(square_number), True, BLACK)\n            screen.blit(text, (x + SQUARE_SIZE // 2 - text.get_width() // 2, y + SQUARE_SIZE // 2 - text.get_height() // 2))\n\n    # Draw Ladders\n    for start, end in ladders.items():\n        start_pos = get_square_position(start)\n        end_pos = get_square_position(end)\n        pygame.draw.line(screen, GREEN, start_pos, end_pos, 5)\n\n    # Draw Snakes\n    for start, end in snakes.items():\n        start_pos = get_square_position(start)\n        end_pos = get_square_position(end)\n        pygame.draw.line(screen, RED, start_pos, end_pos, 5)\n\ndef get_square_position(square):\n    col = (square - 1) % BOARD_SIZE\n    row = (BOARD_SIZE - 1) - (square - 1) // BOARD_SIZE\n    x = col * SQUARE_SIZE + SQUARE_SIZE // 2\n    y = row * SQUARE_SIZE + SQUARE_SIZE // 2\n    return (x, y)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef move_player():\n    global player_pos\n    player_pos += dice_value\n    if player_pos > 100:\n        player_pos = 100\n\n    # Check for ladders and snakes\n    if player_pos in ladders:\n        player_pos = ladders[player_pos]\n    elif player_pos in snakes:\n        player_pos = snakes[player_pos]\n\ndef display_status():\n    font = pygame.font.Font(None, 36)\n    text = font.render(f\"Position: {player_pos} | Dice: {dice_value}\", True, BLACK)\n    screen.blit(text, (10, 10))\n\ndef reset_game():\n    global player_pos, dice_value, game_over\n    player_pos = 1\n    dice_value = 0\n    game_over = False\n\ndef main():\n    global dice_value, game_over\n    \n    while True:\n        screen.fill(BLACK)\n        draw_board()\n        \n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_dice()\n                    move_player()\n                    if player_pos == 100:\n                        game_over = True\n                if event.key == pygame.K_r:\n                    reset_game()\n\n        display_status()\n\n        if game_over:\n            font = pygame.font.Font(None, 72)\n            text = font.render(\"You Win!\", True, BLUE)\n            screen.blit(text, (WINDOW_SIZE // 2 - text.get_width() // 2, WINDOW_SIZE // 2 - text.get_height() // 2))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WIDTH // BOARD_SIZE\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Game variables\nplayer_pos = 1\ngame_over = False\n\n# Ladders and snakes as dictionaries\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Function to draw the board\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = row * SQUARE_SIZE\n            pygame.draw.rect(screen, WHITE, (x, y, SQUARE_SIZE, SQUARE_SIZE), 0)\n            pygame.draw.rect(screen, BLACK, (x, y, SQUARE_SIZE, SQUARE_SIZE), 2)\n            text = font.render(str(square_number), True, BLACK)\n            screen.blit(text, (x + SQUARE_SIZE // 3, y + SQUARE_SIZE // 3))\n\n    # Draw ladders\n    for start, end in ladders.items():\n        start_pos = (start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE\n        end_pos = (end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE\n        pygame.draw.line(screen, GREEN, \n                         (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n    # Draw snakes\n    for start, end in snakes.items():\n        start_pos = (start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE\n        end_pos = (end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE\n        pygame.draw.line(screen, RED, \n                         (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n# Function to roll the dice\ndef roll_dice():\n    return random.randint(1, 6)\n\n# Main game loop\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Snakes and Ladders\")\nfont = pygame.font.Font(None, 36)\nclock = pygame.time.Clock()\n\nrunning = True\nwhile running:\n    screen.fill(BLACK)\n    draw_board()\n    \n    # Display current position and dice value\n    position_text = font.render(f\"Current Position: {player_pos}\", True, WHITE)\n    screen.blit(position_text, (10, 10))\n\n    if game_over:\n        win_text = font.render(\"You Win! Press 'R' to Restart\", True, WHITE)\n        screen.blit(win_text, (WIDTH // 4, HEIGHT // 2))\n    else:\n        dice_text = font.render(\"Press SPACE to Roll Dice!\", True, WHITE)\n        screen.blit(dice_text, (10, 50))\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and not game_over:\n                dice_value = roll_dice()\n                new_position = player_pos + dice_value\n                if new_position > 100:\n                    new_position = player_pos  # Cannot move beyond 100\n                else:\n                    # Check for ladders or snakes\n                    new_position = ladders.get(new_position, snakes.get(new_position, new_position))\n                player_pos = new_position\n                \n                if player_pos == 100:\n                    game_over = True\n            elif event.key == pygame.K_r and game_over:\n                player_pos = 1\n                game_over = False\n\n    pygame.display.flip()\n    clock.tick(FPS)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Initialize Pygame\npygame.init()\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\n# Game variables\nposition = 1\ndice_value = 0\ngame_over = False\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            pygame.draw.rect(window, WHITE, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))\n            pygame.draw.rect(window, BLACK, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 1)\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(square_number), True, BLACK)\n            window.blit(text, (col * SQUARE_SIZE + SQUARE_SIZE // 2 - text.get_width() // 2, \n                               row * SQUARE_SIZE + SQUARE_SIZE // 2 - text.get_height() // 2))\n\ndef draw_player(position):\n    row = (position - 1) // BOARD_SIZE\n    col = (position - 1) % BOARD_SIZE\n    pygame.draw.circle(window, GREEN, (col * SQUARE_SIZE + SQUARE_SIZE // 2, \n                                         row * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 4)\n\ndef display_message(msg):\n    font = pygame.font.Font(None, 48)\n    text = font.render(msg, True, RED)\n    window.blit(text, (WINDOW_SIZE // 2 - text.get_width() // 2, WINDOW_SIZE // 2 - text.get_height() // 2))\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef update_position(position):\n    if position in LADDERS:\n        return LADDERS[position]\n    elif position in SNAKES:\n        return SNAKES[position]\n    return position\n\ndef main():\n    global position, dice_value, game_over\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_dice()\n                    position += dice_value\n                    if position > 100:\n                        position = 100\n                    position = update_position(position)\n                    if position == 100:\n                        game_over = True\n                elif event.key == pygame.K_r:\n                    position = 1\n                    dice_value = 0\n                    game_over = False\n        \n        window.fill(BLACK)\n        draw_board()\n        draw_player(position)\n\n        # Display current position and dice value\n        font = pygame.font.Font(None, 36)\n        position_text = font.render(f\"Position: {position}\", True, WHITE)\n        dice_text = font.render(f\"Dice: {dice_value}\", True, WHITE)\n        window.blit(position_text, (10, 10))\n        window.blit(dice_text, (10, 50))\n\n        if game_over:\n            display_message(\"You Win! Press 'R' to restart.\")\n\n        pygame.display.flip()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nFONT_SIZE = 24\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize screen\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snakes and Ladders')\n\n# Fonts\nfont = pygame.font.Font(None, FONT_SIZE)\n\ndef draw_board():\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            square_number = i * BOARD_SIZE + j + 1\n            color = WHITE if (i + j) % 2 == 0 else GREEN\n            pygame.draw.rect(screen, color, (j * SQUARE_SIZE, i * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=(j * SQUARE_SIZE + SQUARE_SIZE // 2, i * SQUARE_SIZE + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef main():\n    player_position = 1\n    game_over = False\n    dice_value = 0\n\n    while True:\n        screen.fill(BLACK)\n        draw_board()\n\n        # Draw ladders and snakes\n        for start, end in ladders.items():\n            start_pos = ((start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE)\n            end_pos = ((end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE)\n            pygame.draw.line(screen, BLUE, (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                             (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n        for start, end in snakes.items():\n            start_pos = ((start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE)\n            end_pos = ((end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE)\n            pygame.draw.line(screen, RED, (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, start_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2),\n                             (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, end_pos[0] * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\n        # Draw player\n        player_x = ((player_position - 1) % BOARD_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        player_y = ((player_position - 1) // BOARD_SIZE) * SQUARE_SIZE + SQUARE_SIZE // 2\n        pygame.draw.circle(screen, BLACK, (player_x, player_y), SQUARE_SIZE // 4)\n\n        # Display current position and dice value\n        position_text = font.render(f'Position: {player_position}', True, WHITE)\n        dice_text = font.render(f'Dice: {dice_value}', True, WHITE)\n        screen.blit(position_text, (10, 10))\n        screen.blit(dice_text, (10, 50))\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE and not game_over:\n                    dice_value = roll_dice()\n                    next_position = player_position + dice_value\n                    if next_position > 100:\n                        continue\n                    player_position = ladders.get(next_position, snakes.get(next_position, next_position))\n                    if player_position == 100:\n                        game_over = True\n                elif event.key == pygame.K_r:\n                    player_position = 1\n                    game_over = False\n                    dice_value = 0\n\n        pygame.display.flip()\n        pygame.time.Clock().tick(60)\n\nif __name__ == '__main__':\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WIDTH // BOARD_SIZE\nFPS = 30\nFONT_SIZE = 32\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLUE = (0, 0, 255)\n\n# Game State\nposition = 1\ndice_value = 0\ngame_active = True\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Create display\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Snakes and Ladders\")\nfont = pygame.font.Font(None, FONT_SIZE)\n\ndef draw_board():\n    for row in range(BOARD_SIZE):\n        for col in range(BOARD_SIZE):\n            square_number = row * BOARD_SIZE + col + 1\n            x = col * SQUARE_SIZE\n            y = HEIGHT - (row + 1) * SQUARE_SIZE\n            color = WHITE if (row + col) % 2 == 0 else (200, 200, 200)\n            pygame.draw.rect(screen, color, (x, y, SQUARE_SIZE, SQUARE_SIZE), 0)\n            text = font.render(str(square_number), True, BLACK)\n            text_rect = text.get_rect(center=(x + SQUARE_SIZE // 2, y + SQUARE_SIZE // 2))\n            screen.blit(text, text_rect)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef move_player(position, roll):\n    new_position = position + roll\n    if new_position > 100:\n        return position\n    return ladders.get(new_position, snakes.get(new_position, new_position))\n\ndef reset_game():\n    global position, dice_value, game_active\n    position = 1\n    dice_value = 0\n    game_active = True\n\ndef display_status():\n    status_text = f\"Current Position: {position} | Dice Value: {dice_value}\"\n    text = font.render(status_text, True, BLACK)\n    screen.blit(text, (10, 10))\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and game_active:\n                dice_value = roll_dice()\n                position = move_player(position, dice_value)\n                if position == 100:\n                    game_active = False\n            if event.key == pygame.K_r:\n                reset_game()\n\n    screen.fill(BLACK)\n    draw_board()\n    display_status()\n    pygame.display.flip()\n    clock.tick(FPS)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWIDTH, HEIGHT = 600, 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WIDTH // BOARD_SIZE\nFPS = 30\n\n# Colors\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Ladders and Snakes\nladders = {3: 22, 5: 8, 11: 26, 20: 29}\nsnakes = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\n# Initialize Pygame\npygame.init()\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Snakes and Ladders\")\nclock = pygame.time.Clock()\n\n# Game Variables\nplayer_pos = 1\ndice_value = 0\ngame_over = False\n\ndef draw_board():\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            rect = pygame.Rect(j * SQUARE_SIZE, HEIGHT - (i + 1) * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            pygame.draw.rect(screen, WHITE, rect, 1)\n            # Numbers\n            num = i * BOARD_SIZE + j + 1\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(num), True, BLACK)\n            screen.blit(text, (j * SQUARE_SIZE + SQUARE_SIZE // 3, HEIGHT - (i + 1) * SQUARE_SIZE + SQUARE_SIZE // 4))\n            \n    # Draw Ladders\n    for start, end in ladders.items():\n        start_pos = (start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE\n        end_pos = (end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE\n        pygame.draw.line(screen, GREEN, (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT - (start_pos[0] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT - (end_pos[0] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n    \n    # Draw Snakes\n    for start, end in snakes.items():\n        start_pos = (start - 1) // BOARD_SIZE, (start - 1) % BOARD_SIZE\n        end_pos = (end - 1) // BOARD_SIZE, (end - 1) % BOARD_SIZE\n        pygame.draw.line(screen, RED, (start_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT - (start_pos[0] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2),\n                         (end_pos[1] * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT - (end_pos[0] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2), 5)\n\ndef draw_player():\n    player_pos_on_board = (player_pos - 1) // BOARD_SIZE, (player_pos - 1) % BOARD_SIZE\n    pygame.draw.circle(screen, BLACK, (player_pos_on_board[1] * SQUARE_SIZE + SQUARE_SIZE // 2, HEIGHT - (player_pos_on_board[0] + 1) * SQUARE_SIZE + SQUARE_SIZE // 2), SQUARE_SIZE // 4)\n\ndef reset_game():\n    global player_pos, dice_value, game_over\n    player_pos = 1\n    dice_value = 0\n    game_over = False\n\n# Main Game Loop\nrunning = True\nwhile running:\n    screen.fill(BLACK)\n    draw_board()\n    draw_player()\n\n    # Display current position and dice value\n    font = pygame.font.Font(None, 36)\n    pos_text = font.render(f\"Position: {player_pos}\", True, WHITE)\n    dice_text = font.render(f\"Dice: {dice_value}\", True, WHITE)\n    screen.blit(pos_text, (10, 10))\n    screen.blit(dice_text, (10, 50))\n\n    if game_over:\n        win_text = font.render(\"You Win! Press 'R' to Restart\", True, WHITE)\n        screen.blit(win_text, (WIDTH // 6, HEIGHT // 2))\n\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and not game_over:\n                dice_value = random.randint(1, 6)\n                new_position = player_pos + dice_value\n                if new_position > 100:\n                    new_position = player_pos  # Cannot move beyond 100\n                else:\n                    player_pos = ladders.get(new_position, snakes.get(new_position, new_position))\n                if player_pos == 100:\n                    game_over = True\n            if event.key == pygame.K_r:\n                reset_game()\n\n    pygame.display.flip()\n    clock.tick(FPS)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\nWHITE = (255, 255, 255)\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Game variables\nplayer_position = 1\ndice_value = 0\ngame_over = False\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snakes and Ladders\")\n\ndef draw_board():\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            rect = pygame.Rect(j * SQUARE_SIZE, i * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n            pygame.draw.rect(screen, WHITE, rect, 1)\n            # Draw board numbers\n            number = (BOARD_SIZE - i) * BOARD_SIZE - j\n            font = pygame.font.Font(None, 36)\n            text = font.render(str(number), True, BLACK)\n            screen.blit(text, (j * SQUARE_SIZE + SQUARE_SIZE // 3, i * SQUARE_SIZE + SQUARE_SIZE // 4))\n\n    # Draw ladders\n    for start, end in LADDERS.items():\n        start_pos = get_position_coordinates(start)\n        end_pos = get_position_coordinates(end)\n        pygame.draw.line(screen, GREEN, start_pos, end_pos, 5)\n\n    # Draw snakes\n    for start, end in SNAKES.items():\n        start_pos = get_position_coordinates(start)\n        end_pos = get_position_coordinates(end)\n        pygame.draw.line(screen, RED, start_pos, end_pos, 5)\n\ndef get_position_coordinates(position):\n    row = (100 - position) // BOARD_SIZE\n    col = (position - 1) % BOARD_SIZE\n    return (col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2)\n\ndef roll_dice():\n    return random.randint(1, 6)\n\ndef update_position():\n    global player_position\n    if player_position in LADDERS:\n        player_position = LADDERS[player_position]\n    elif player_position in SNAKES:\n        player_position = SNAKES[player_position]\n\ndef reset_game():\n    global player_position, dice_value, game_over\n    player_position = 1\n    dice_value = 0\n    game_over = False\n\n# Game loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE and not game_over:\n                dice_value = roll_dice()\n                player_position += dice_value\n                if player_position > 100:\n                    player_position = 100\n                update_position()\n                if player_position == 100:\n                    game_over = True\n            if event.key == pygame.K_r:\n                reset_game()\n\n    screen.fill(BLACK)\n    draw_board()\n\n    # Display current position and dice value\n    font = pygame.font.Font(None, 36)\n    position_text = font.render(f\"Position: {player_position}\", True, WHITE)\n    dice_text = font.render(f\"Dice: {dice_value}\", True, WHITE)\n    screen.blit(position_text, (10, 10))\n    screen.blit(dice_text, (10, 50))\n\n    if game_over:\n        win_text = font.render(\"You Win! Press R to Restart\", True, WHITE)\n        screen.blit(win_text, (WINDOW_SIZE // 4, WINDOW_SIZE // 2))\n\n    pygame.display.flip()\n    pygame.time.delay(100)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Constants\nWINDOW_SIZE = 600\nBOARD_SIZE = 10\nSQUARE_SIZE = WINDOW_SIZE // BOARD_SIZE\nLADDERS = {3: 22, 5: 8, 11: 26, 20: 29}\nSNAKES = {27: 1, 21: 9, 19: 7, 25: 13, 15: 6}\n\nclass Game:\n    def __init__(self):\n        self.player_position = 1\n        self.dice_value = 0\n        self.font = pygame.font.Font(None, 36)\n        self.running = True\n\n    def roll_dice(self):\n        self.dice_value = random.randint(1, 6)\n        self.move_player(self.dice_value)\n\n    def move_player(self, steps):\n        self.player_position += steps\n        if self.player_position > 100:\n            self.player_position = 100\n        \n        # Check for ladders and snakes\n        if self.player_position in LADDERS:\n            self.player_position = LADDERS[self.player_position]\n        elif self.player_position in SNAKES:\n            self.player_position = SNAKES[self.player_position]\n\n    def reset(self):\n        self.player_position = 1\n        self.dice_value = 0\n\n    def draw_board(self, screen):\n        for row in range(BOARD_SIZE):\n            for col in range(BOARD_SIZE):\n                square_number = row * BOARD_SIZE + col + 1\n                rect = pygame.Rect(col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE)\n                pygame.draw.rect(screen, (255, 255, 255), rect)\n                pygame.draw.rect(screen, (0, 0, 0), rect, 1)\n                text = self.font.render(str(square_number), True, (0, 0, 0))\n                screen.blit(text, (col * SQUARE_SIZE + SQUARE_SIZE // 4, row * SQUARE_SIZE + SQUARE_SIZE // 4))\n\n        # Draw ladders\n        for start, end in LADDERS.items():\n            start_pos = self.pos_to_coords(start)\n            end_pos = self.pos_to_coords(end)\n            pygame.draw.line(screen, (0, 255, 0), start_pos, end_pos, 5)\n\n        # Draw snakes\n        for start, end in SNAKES.items():\n            start_pos = self.pos_to_coords(start)\n            end_pos = self.pos_to_coords(end)\n            pygame.draw.line(screen, (255, 0, 0), start_pos, end_pos, 5)\n\n    def pos_to_coords(self, pos):\n        row = (pos - 1) // BOARD_SIZE\n        col = (pos - 1) % BOARD_SIZE\n        x = col * SQUARE_SIZE + SQUARE_SIZE // 2\n        y = row * SQUARE_SIZE + SQUARE_SIZE // 2\n        return (x, y)\n\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption(\"Snakes and Ladders\")\n    clock = pygame.time.Clock()\n\n    game = Game()\n\n    while game.running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game.running = False\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    game.roll_dice()\n                if event.key == pygame.K_r:\n                    game.reset()\n\n        screen.fill((0, 128, 0))  # Background color\n        game.draw_board(screen)\n\n        # Display current position and dice value\n        position_text = game.font.render(f\"Position: {game.player_position}\", True, (255, 255, 255))\n        dice_text = game.font.render(f\"Dice: {game.dice_value}\", True, (255, 255, 255))\n        screen.blit(position_text, (10, 10))\n        screen.blit(dice_text, (10, 50))\n\n        if game.player_position == 100:\n            win_text = game.font.render(\"You Win! Press R to Restart\", True, (255, 255, 0))\n            screen.blit(win_text, (WINDOW_SIZE // 2 - 150, WINDOW_SIZE // 2))\n\n        pygame.display.flip()\n        clock.tick(60)\n\n    pygame.quit()\n    sys.exit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      }
    ]
  },
  "snake_game": {
    "openai": [
      {
        "code": "import pygame\nimport random\n\n# Initialize pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Initialize window\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\n\n# Snake and fruit initializations\ndef create_fruit():\n    return (random.randint(0, GRID_SIZE - 1) * CELL_SIZE,\n            random.randint(0, GRID_SIZE - 1) * CELL_SIZE)\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(window, GREEN, pygame.Rect(segment[0], segment[1], CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(window, RED, pygame.Rect(fruit[0], fruit[1], CELL_SIZE, CELL_SIZE))\n\ndef main():\n    clock = pygame.time.Clock()\n    game_over = False\n    score = 0\n\n    snake = [(CELL_SIZE * 3, CELL_SIZE), (CELL_SIZE * 2, CELL_SIZE), (CELL_SIZE, CELL_SIZE)]\n    direction = (CELL_SIZE, 0)  # Initially moving right\n    fruit = create_fruit()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            \n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != (0, CELL_SIZE):\n                    direction = (0, -CELL_SIZE)\n                elif event.key == pygame.K_DOWN and direction != (0, -CELL_SIZE):\n                    direction = (0, CELL_SIZE)\n                elif event.key == pygame.K_LEFT and direction != (CELL_SIZE, 0):\n                    direction = (-CELL_SIZE, 0)\n                elif event.key == pygame.K_RIGHT and direction != (-CELL_SIZE, 0):\n                    direction = (CELL_SIZE, 0)\n\n        if not game_over:\n            # Move the snake\n            new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n            snake.insert(0, new_head)\n\n            # Check for fruit collision\n            if snake[0] == fruit:\n                score += 1\n                fruit = create_fruit()\n            else:\n                snake.pop()  # Remove the last segment of the snake\n            \n            # Check for collisions with walls or self\n            if (snake[0][0] < 0 or snake[0][0] >= WINDOW_SIZE or\n                snake[0][1] < 0 or snake[0][1] >= WINDOW_SIZE or\n                snake[0] in snake[1:]):\n                game_over = True\n\n        # Drawing everything\n        window.fill(BLACK)\n        draw_snake(snake)\n        draw_fruit(fruit)\n\n        # Display score\n        font = pygame.font.SysFont('Arial', 24)\n        score_surface = font.render(f'Score: {score}', True, (255, 255, 255))\n        window.blit(score_surface, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n        if game_over:\n            # Reset game\n            pygame.time.delay(1000)  # Pause before restarting\n            snake = [(CELL_SIZE * 3, CELL_SIZE), (CELL_SIZE * 2, CELL_SIZE), (CELL_SIZE, CELL_SIZE)]\n            direction = (CELL_SIZE, 0)\n            fruit = create_fruit()\n            score = 0\n            game_over = False\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Game setup\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\nclock = pygame.time.Clock()\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(screen, RED, (fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef main():\n    score = 0\n    snake = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n    direction = RIGHT\n    fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    running = True\n    while running:\n        screen.fill(BLACK)\n        draw_snake(snake)\n        draw_fruit(fruit)\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        # Move snake\n        head_x, head_y = snake[0]\n        new_head = (head_x + direction[0], head_y + direction[1])\n\n        # Check for collisions\n        if (new_head[0] < 0 or new_head[0] >= GRID_SIZE or\n            new_head[1] < 0 or new_head[1] >= GRID_SIZE or\n            new_head in snake):\n            score = 0\n            snake = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n            direction = RIGHT\n            fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n            continue\n\n        snake.insert(0, new_head)\n\n        # Check if snake eats fruit\n        if new_head == fruit:\n            score += 1\n            fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n            while fruit in snake:  # Ensure fruit does not spawn on the snake\n                fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        else:\n            snake.pop()\n\n        # Draw score\n        font = pygame.font.SysFont('Arial', 24)\n        score_text = font.render(f'Score: {score}', True, (255, 255, 255))\n        screen.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Initialize the display\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\n\n# Function to draw the snake\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(window, GREEN, pygame.Rect(segment[0], segment[1], CELL_SIZE, CELL_SIZE))\n\n# Function to generate a new fruit\ndef generate_fruit(snake):\n    while True:\n        fruit_position = (random.randint(0, GRID_SIZE - 1) * CELL_SIZE,\n                          random.randint(0, GRID_SIZE - 1) * CELL_SIZE)\n        if fruit_position not in snake:\n            return fruit_position\n\n# Main function\ndef main():\n    clock = pygame.time.Clock()\n    snake = [(CELL_SIZE * 3, CELL_SIZE), (CELL_SIZE * 2, CELL_SIZE), (CELL_SIZE, CELL_SIZE)]\n    direction = (CELL_SIZE, 0)  # Start moving right\n    fruit = generate_fruit(snake)\n    score = 0\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != (0, CELL_SIZE):\n                    direction = (0, -CELL_SIZE)\n                elif event.key == pygame.K_DOWN and direction != (0, -CELL_SIZE):\n                    direction = (0, CELL_SIZE)\n                elif event.key == pygame.K_LEFT and direction != (CELL_SIZE, 0):\n                    direction = (-CELL_SIZE, 0)\n                elif event.key == pygame.K_RIGHT and direction != (-CELL_SIZE, 0):\n                    direction = (CELL_SIZE, 0)\n\n        if not game_over:\n            # Move the snake\n            new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n            # Check for collisions with walls or itself\n            if (new_head[0] < 0 or new_head[0] >= WINDOW_SIZE or\n                new_head[1] < 0 or new_head[1] >= WINDOW_SIZE or\n                new_head in snake):\n                game_over = True\n            else:\n                snake.insert(0, new_head)\n                # Check if snake eats the fruit\n                if new_head == fruit:\n                    score += 1\n                    fruit = generate_fruit(snake)\n                else:\n                    snake.pop()\n        \n        # Drawing\n        window.fill(BLACK)\n        draw_snake(snake)\n        pygame.draw.rect(window, RED, pygame.Rect(fruit[0], fruit[1], CELL_SIZE, CELL_SIZE))\n        \n        # Display score\n        font = pygame.font.SysFont(None, 35)\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        window.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n        # Restart game if game over\n        if game_over:\n            snake = [(CELL_SIZE * 3, CELL_SIZE), (CELL_SIZE * 2, CELL_SIZE), (CELL_SIZE, CELL_SIZE)]\n            direction = (CELL_SIZE, 0)  # Reset direction\n            fruit = generate_fruit(snake)\n            score = 0\n            game_over = False\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\nclass SnakeGame:\n    def __init__(self):\n        self.window = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n        pygame.display.set_caption('Snake Game')\n        self.clock = pygame.time.Clock()\n        self.font = pygame.font.SysFont('Arial', 25)\n        self.reset_game()\n\n    def reset_game(self):\n        self.snake = [(GRID_SIZE // 2, GRID_SIZE // 2),\n                      (GRID_SIZE // 2 - 1, GRID_SIZE // 2),\n                      (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n        self.direction = RIGHT\n        self.fruit = self.place_fruit()\n        self.score = 0\n        self.game_over = False\n\n    def place_fruit(self):\n        while True:\n            x = random.randint(0, GRID_SIZE - 1)\n            y = random.randint(0, GRID_SIZE - 1)\n            if (x, y) not in self.snake:\n                return (x, y)\n\n    def draw_snake(self):\n        for segment in self.snake:\n            pygame.draw.rect(self.window, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def draw_fruit(self):\n        pygame.draw.rect(self.window, RED, (self.fruit[0] * CELL_SIZE, self.fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n    def check_collisions(self):\n        head = self.snake[0]\n        # Check wall collision\n        if head[0] < 0 or head[0] >= GRID_SIZE or head[1] < 0 or head[1] >= GRID_SIZE:\n            return True\n        # Check self collision\n        if head in self.snake[1:]:\n            return True\n        return False\n\n    def update_snake(self):\n        head_x, head_y = self.snake[0]\n        move_x, move_y = self.direction\n        new_head = (head_x + move_x, head_y + move_y)\n        \n        self.snake.insert(0, new_head)\n        \n        # Check if fruit is eaten\n        if new_head == self.fruit:\n            self.score += 1\n            self.fruit = self.place_fruit()\n        else:\n            self.snake.pop()  # Remove the last segment\n\n        if self.check_collisions():\n            self.game_over = True\n\n    def handle_input(self):\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and self.direction != DOWN:\n                    self.direction = UP\n                elif event.key == pygame.K_DOWN and self.direction != UP:\n                    self.direction = DOWN\n                elif event.key == pygame.K_LEFT and self.direction != RIGHT:\n                    self.direction = LEFT\n                elif event.key == pygame.K_RIGHT and self.direction != LEFT:\n                    self.direction = RIGHT\n\n    def draw_score(self):\n        score_text = self.font.render(f'Score: {self.score}', True, BLACK)\n        self.window.blit(score_text, (10, 10))\n\n    def run(self):\n        while True:\n            self.handle_input()\n\n            if not self.game_over:\n                self.update_snake()\n\n            self.window.fill(BLACK)\n            self.draw_snake()\n            self.draw_fruit()\n            self.draw_score()\n\n            if self.game_over:\n                self.reset_game()  # Restart the game on collision\n\n            pygame.display.flip()\n            self.clock.tick(FPS)\n\nif __name__ == '__main__':\n    game = SnakeGame()\n    game.run()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport time\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Initialize screen\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\n\n# Clock to control game speed\nclock = pygame.time.Clock()\n\n# Game variables\nsnake_pos = [[100, 100], [80, 100], [60, 100]]  # Starting position\nsnake_direction = 'RIGHT'\nfruit_pos = [random.randrange(1, GRID_SIZE) * CELL_SIZE, random.randrange(1, GRID_SIZE) * CELL_SIZE]\nscore = 0\n\ndef restart_game():\n    global snake_pos, snake_direction, fruit_pos, score\n    snake_pos = [[100, 100], [80, 100], [60, 100]]\n    snake_direction = 'RIGHT'\n    fruit_pos = [random.randrange(1, GRID_SIZE) * CELL_SIZE, random.randrange(1, GRID_SIZE) * CELL_SIZE]\n    score = 0\n\ndef game_over():\n    font = pygame.font.SysFont('Arial', 35)\n    message = font.render(f\"Game Over! Score: {score}\", True, BLACK)\n    screen.blit(message, [WINDOW_SIZE // 4, WINDOW_SIZE // 3])\n    pygame.display.flip()\n    time.sleep(2)\n    restart_game()\n\n# Main game loop\ndef game_loop():\n    global snake_direction\n    while True:\n        # Event handling\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and snake_direction != 'DOWN':\n                    snake_direction = 'UP'\n                elif event.key == pygame.K_DOWN and snake_direction != 'UP':\n                    snake_direction = 'DOWN'\n                elif event.key == pygame.K_LEFT and snake_direction != 'RIGHT':\n                    snake_direction = 'LEFT'\n                elif event.key == pygame.K_RIGHT and snake_direction != 'LEFT':\n                    snake_direction = 'RIGHT'\n\n        # Move snake\n        if snake_direction == 'UP':\n            new_head = [snake_pos[0][0], snake_pos[0][1] - CELL_SIZE]\n        elif snake_direction == 'DOWN':\n            new_head = [snake_pos[0][0], snake_pos[0][1] + CELL_SIZE]\n        elif snake_direction == 'LEFT':\n            new_head = [snake_pos[0][0] - CELL_SIZE, snake_pos[0][1]]\n        elif snake_direction == 'RIGHT':\n            new_head = [snake_pos[0][0] + CELL_SIZE, snake_pos[0][1]]\n\n        # Check for wall collisions\n        if (new_head[0] < 0 or new_head[0] >= WINDOW_SIZE or \n            new_head[1] < 0 or new_head[1] >= WINDOW_SIZE or \n            new_head in snake_pos):\n            game_over()\n\n        # Insert new head\n        snake_pos.insert(0, new_head)\n\n        # Check if snake eats fruit\n        if snake_pos[0] == fruit_pos:\n            global score\n            score += 1\n            fruit_pos[0] = random.randrange(1, GRID_SIZE) * CELL_SIZE\n            fruit_pos[1] = random.randrange(1, GRID_SIZE) * CELL_SIZE\n        else:\n            snake_pos.pop()  # Remove last segment if no fruit eaten\n\n        # Draw everything\n        screen.fill(WHITE)\n        for pos in snake_pos:\n            pygame.draw.rect(screen, GREEN, pygame.Rect(pos[0], pos[1], CELL_SIZE, CELL_SIZE))\n        pygame.draw.rect(screen, RED, pygame.Rect(fruit_pos[0], fruit_pos[1], CELL_SIZE, CELL_SIZE))\n\n        # Display score\n        font = pygame.font.SysFont('Arial', 20)\n        score_surface = font.render(f\"Score: {score}\", True, BLACK)\n        screen.blit(score_surface, [10, 10])\n\n        pygame.display.update()\n\n        # Control game speed\n        clock.tick(10)\n\n# Start the game loop\nrestart_game()\ngame_loop()\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport time\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 600\nWINDOW_HEIGHT = 600\nCELL_SIZE = 20\nGRID_WIDTH = WINDOW_WIDTH // CELL_SIZE\nGRID_HEIGHT = WINDOW_HEIGHT // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Game Variables\nsnake = [(GRID_WIDTH // 2, GRID_HEIGHT // 2), \n         (GRID_WIDTH // 2 - 1, GRID_HEIGHT // 2), \n         (GRID_WIDTH // 2 - 2, GRID_HEIGHT // 2)]\nsnake_direction = RIGHT\nfruit_position = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))\nscore = 0\ngame_over = False\n\n# Setup display\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption('Snake Game')\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(position):\n    pygame.draw.rect(screen, RED, (position[0] * CELL_SIZE, position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef check_collision(snake):\n    head = snake[0]\n    if head[0] < 0 or head[0] >= GRID_WIDTH or head[1] < 0 or head[1] >= GRID_HEIGHT or head in snake[1:]:\n        return True\n    return False\n\ndef reset_game():\n    global snake, snake_direction, fruit_position, score, game_over\n    snake = [(GRID_WIDTH // 2, GRID_HEIGHT // 2), \n             (GRID_WIDTH // 2 - 1, GRID_HEIGHT // 2), \n             (GRID_WIDTH // 2 - 2, GRID_HEIGHT // 2)]\n    snake_direction = RIGHT\n    fruit_position = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))\n    score = 0\n    game_over = False\n\n# Game loop\nclock = pygame.time.Clock()\nreset_game()\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            exit()\n\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_UP and snake_direction != DOWN:\n                snake_direction = UP\n            elif event.key == pygame.K_DOWN and snake_direction != UP:\n                snake_direction = DOWN\n            elif event.key == pygame.K_LEFT and snake_direction != RIGHT:\n                snake_direction = LEFT\n            elif event.key == pygame.K_RIGHT and snake_direction != LEFT:\n                snake_direction = RIGHT\n\n    if not game_over:\n        # Move the snake\n        new_head = (snake[0][0] + snake_direction[0], snake[0][1] + snake_direction[1])\n        snake.insert(0, new_head)\n\n        # Check if snake has eaten the fruit\n        if snake[0] == fruit_position:\n            score += 1\n            fruit_position = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))\n            while fruit_position in snake:  # Make sure fruit does not spawn on snake\n                fruit_position = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))\n        else:\n            snake.pop()  # Remove last segment unless fruit eaten\n\n        # Check for collisions\n        if check_collision(snake):\n            game_over = True\n\n    # Draw everything\n    screen.fill(BLACK)\n    draw_snake(snake)\n    draw_fruit(fruit_position)\n\n    # Display score\n    font = pygame.font.SysFont('Arial', 25)\n    score_text = font.render(f'Score: {score}', True, (255, 255, 255))\n    screen.blit(score_text, (10, 10))\n\n    # Refresh the display\n    pygame.display.flip()\n\n    # Reset game on collision\n    if game_over:\n        time.sleep(1)\n        reset_game()\n\n    clock.tick(FPS)",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Initialize the game window\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\n\n# Clock to control the game's frame rate\nclock = pygame.time.Clock()\n\n# Snake class\nclass Snake:\n    def __init__(self):\n        self.segments = [(GRID_SIZE//2, GRID_SIZE//2), (GRID_SIZE//2 - 1, GRID_SIZE//2), (GRID_SIZE//2 - 2, GRID_SIZE//2)]\n        self.direction = (1, 0)  # Start moving right\n\n    def get_head_position(self):\n        return self.segments[0]\n\n    def turn(self, point):\n        if (point[0] * -1, point[1] * -1) == self.direction:\n            return  # Prevent snake from reversing\n        else:\n            self.direction = point\n\n    def move(self):\n        cur = self.get_head_position()\n        x, y = self.direction\n        new = ((cur[0] + x) % GRID_SIZE, (cur[1] + y) % GRID_SIZE)  # Wrap around screen\n        if len(self.segments) > 2 and new in self.segments:\n            self.reset()\n        else:\n            self.segments.insert(0, new)\n            self.segments.pop()  # Remove last segment\n\n    def grow(self):\n        cur = self.get_head_position()\n        x, y = self.direction\n        new = ((cur[0] + x) % GRID_SIZE, (cur[1] + y) % GRID_SIZE)\n        self.segments.insert(0, new)  # Add new segment at head\n\n    def reset(self):\n        self.segments = [(GRID_SIZE//2, GRID_SIZE//2), (GRID_SIZE//2 - 1, GRID_SIZE//2), (GRID_SIZE//2 - 2, GRID_SIZE//2)]\n        self.direction = (1, 0)\n\n    def draw(self, surface):\n        for segment in self.segments:\n            pygame.draw.rect(surface, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n# Fruit class\nclass Fruit:\n    def __init__(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n    \n    def spawn(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def draw(self, surface):\n        pygame.draw.rect(surface, RED, (self.position[0] * CELL_SIZE, self.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n# Main function\ndef main():\n    snake = Snake()\n    fruit = Fruit()\n    score = 0\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.turn((0, -1))\n                elif event.key == pygame.K_DOWN:\n                    snake.turn((0, 1))\n                elif event.key == pygame.K_LEFT:\n                    snake.turn((-1, 0))\n                elif event.key == pygame.K_RIGHT:\n                    snake.turn((1, 0))\n\n        if not game_over:\n            snake.move()\n            head_pos = snake.get_head_position()\n\n            # Check for fruit collision\n            if head_pos == fruit.position:\n                snake.grow()\n                fruit.spawn()\n                score += 1\n\n            # Check for wall collision\n            if head_pos[0] < 0 or head_pos[0] >= GRID_SIZE or head_pos[1] < 0 or head_pos[1] >= GRID_SIZE:\n                game_over = True\n\n            # Check for self collision\n            if len(snake.segments) > 1 and head_pos in snake.segments[1:]:\n                game_over = True\n\n        # Drawing everything\n        window.fill(BLACK)\n        snake.draw(window)\n        fruit.draw(window)\n\n        # Display score\n        font = pygame.font.SysFont('Arial', 25)\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        window.blit(score_text, (10, 10))\n\n        pygame.display.update()\n        clock.tick(FPS)\n\n        # Restart game on collision\n        if game_over:\n            pygame.time.delay(1000)  # Wait for a second before resetting\n            snake.reset()\n            score = 0\n            game_over = False\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\nclass Snake:\n    def __init__(self):\n        self.body = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n        self.direction = RIGHT\n        self.score = 0\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        delta_x, delta_y = self.direction\n        new_head = (head_x + delta_x, head_y + delta_y)\n\n        # Insert new head and remove the tail\n        self.body.insert(0, new_head)\n        self.body.pop()\n\n    def grow(self):\n        self.score += 1\n        self.body.append(self.body[-1])  # Duplicate tail segment to grow\n\n    def change_direction(self, new_direction):\n        if (new_direction[0] * -1, new_direction[1] * -1) != self.direction:  # Prevent reversing\n            self.direction = new_direction\n\n    def check_collision(self):\n        head = self.body[0]\n        # Check wall collision\n        if head[0] < 0 or head[0] >= GRID_SIZE or head[1] < 0 or head[1] >= GRID_SIZE:\n            return True\n        # Check self collision\n        if head in self.body[1:]:\n            return True\n        return False\n\n    def reset(self):\n        self.__init__()\n\nclass Fruit:\n    def __init__(self):\n        self.position = self.spawn()\n\n    def spawn(self):\n        return (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\ndef draw_window(snake, fruit, score):\n    window.fill(BLACK)\n    # Draw snake\n    for segment in snake.body:\n        pygame.draw.rect(window, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n    # Draw fruit\n    pygame.draw.rect(window, RED, (fruit.position[0] * CELL_SIZE, fruit.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n    \n    # Draw score\n    score_text = font.render(f'Score: {snake.score}', True, (255, 255, 255))\n    window.blit(score_text, (10, 10))\n    \n    pygame.display.update()\n\n# Main game loop\ndef main():\n    global window, font\n    window = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption('Snake Game')\n    clock = pygame.time.Clock()\n    font = pygame.font.SysFont('Arial', 30)\n\n    snake = Snake()\n    fruit = Fruit()\n\n    running = True\n    while running:\n        clock.tick(FPS)\n        \n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction(UP)\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction(DOWN)\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction(LEFT)\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction(RIGHT)\n\n        snake.move()\n\n        # Check for fruit collision\n        if snake.body[0] == fruit.position:\n            snake.grow()\n            fruit.position = fruit.spawn()\n\n        # Check for collisions\n        if snake.check_collision():\n            snake.reset()\n            fruit.position = fruit.spawn()\n\n        draw_window(snake, fruit, snake.score)\n\n    pygame.quit()\n\nif __name__ == '__main__':\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport time\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 15\n\n# Colors\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nWHITE = (255, 255, 255)\n\n# Initialize the display\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\n\n# Snake class\nclass Snake:\n    def __init__(self):\n        self.body = [(GRID_SIZE // 2, GRID_SIZE // 2)]\n        self.direction = (1, 0)  # Moving right initially\n        self.grow = False\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        dir_x, dir_y = self.direction\n        new_head = ((head_x + dir_x) % GRID_SIZE, (head_y + dir_y) % GRID_SIZE)\n\n        if self.grow:\n            self.body.insert(0, new_head)\n            self.grow = False\n        else:\n            self.body.insert(0, new_head)\n            self.body.pop()\n\n    def change_direction(self, new_direction):\n        # Prevent the snake from reversing\n        opposite_direction = (-self.direction[0], -self.direction[1])\n        if new_direction != opposite_direction:\n            self.direction = new_direction\n\n    def grow_snake(self):\n        self.grow = True\n\n    def check_collision(self):\n        head = self.body[0]\n        return head in self.body[1:]  # Check if head collides with itself\n\n    def draw(self):\n        for segment in self.body:\n            pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n# Fruit class\nclass Fruit:\n    def __init__(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def spawn(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def draw(self):\n        pygame.draw.rect(screen, RED, (self.position[0] * CELL_SIZE, self.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n# Main game function\ndef game_loop():\n    snake = Snake()\n    fruit = Fruit()\n    score = 0\n    clock = pygame.time.Clock()\n    game_over = False\n\n    while True:\n        while game_over:\n            screen.fill(BLACK)\n            font = pygame.font.SysFont('Arial', 35)\n            text = font.render(f'Game Over! Score: {score}', True, WHITE)\n            screen.blit(text, (WINDOW_SIZE // 2 - text.get_width() // 2, WINDOW_SIZE // 2 - text.get_height() // 2))\n            pygame.display.flip()\n            time.sleep(2)\n            game_loop()  # Restart game\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                quit()\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction((0, -1))\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction((0, 1))\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction((-1, 0))\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction((1, 0))\n\n        snake.move()\n\n        # Check for collision with walls\n        if snake.check_collision():\n            game_over = True\n\n        # Check for fruit collision\n        if snake.body[0] == fruit.position:\n            snake.grow_snake()\n            score += 1\n            fruit.spawn()\n\n        screen.fill(BLACK)\n        snake.draw()\n        fruit.draw()\n\n        # Draw the score\n        font = pygame.font.SysFont('Arial', 20)\n        score_text = font.render(f'Score: {score}', True, WHITE)\n        screen.blit(score_text, (5, 5))\n\n        pygame.display.update()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    game_loop()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nWHITE = (255, 255, 255)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nFPS = 15\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Game settings\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\nclock = pygame.time.Clock()\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(screen, GREEN, pygame.Rect(segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(screen, RED, pygame.Rect(fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef place_fruit(snake):\n    while True:\n        fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        if fruit not in snake:\n            return fruit\n\ndef main():\n    snake = [(5, 5), (5, 6), (5, 7)]  # Snake starts with 3 segments\n    direction = RIGHT\n    fruit = place_fruit(snake)\n    score = 0\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        # Move snake\n        new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n        \n        # Check for collisions\n        if (new_head[0] < 0 or new_head[0] >= GRID_SIZE or\n            new_head[1] < 0 or new_head[1] >= GRID_SIZE or\n            new_head in snake):\n            snake = [(5, 5), (5, 6), (5, 7)]  # Reset the snake\n            direction = RIGHT\n            fruit = place_fruit(snake)\n            score = 0  # Reset score\n\n        # Check if snake eats fruit\n        if new_head == fruit:\n            snake.insert(0, new_head)  # Add new head\n            fruit = place_fruit(snake)  # Place new fruit\n            score += 1  # Increase score\n        else:\n            snake.insert(0, new_head)  # Add new head\n            snake.pop()  # Remove last segment\n\n        # Draw everything\n        screen.fill(WHITE)\n        draw_snake(snake)\n        draw_fruit(fruit)\n\n        # Display score\n        score_font = pygame.font.SysFont('Arial', 24)\n        score_surface = score_font.render(f'Score: {score}', True, (0, 0, 0))\n        screen.blit(score_surface, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10  # Frames per second\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Snake class\nclass Snake:\n    def __init__(self):\n        self.body = [(3, 0), (2, 0), (1, 0)]  # Initial snake segments\n        self.direction = RIGHT\n        self.grow_segment = False\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        dir_x, dir_y = self.direction\n        new_head = (head_x + dir_x, head_y + dir_y)\n\n        if self.grow_segment:\n            self.body.insert(0, new_head)\n            self.grow_segment = False\n        else:\n            self.body.insert(0, new_head)\n            self.body.pop()\n\n    def change_direction(self, new_direction):\n        # Prevent reversing direction\n        if (self.direction[0] + new_direction[0] != 0) or (self.direction[1] + new_direction[1] != 0):\n            self.direction = new_direction\n\n    def grow(self):\n        self.grow_segment = True\n\n    def check_collision(self):\n        head = self.body[0]\n        # Check wall collision\n        if head[0] < 0 or head[0] >= GRID_SIZE or head[1] < 0 or head[1] >= GRID_SIZE:\n            return True\n        # Check self collision\n        if head in self.body[1:]:\n            return True\n        return False\n\n# Fruit class\nclass Fruit:\n    def __init__(self):\n        self.position = self.random_position()\n\n    def random_position(self):\n        return (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def respawn(self):\n        self.position = self.random_position()\n\n# Main game function\ndef main():\n    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption(\"Snake Game\")\n    clock = pygame.time.Clock()\n\n    snake = Snake()\n    fruit = Fruit()\n    score = 0\n\n    running = True\n    while running:\n        screen.fill(BLACK)\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction(UP)\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction(DOWN)\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction(LEFT)\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction(RIGHT)\n\n        snake.move()\n\n        # Check if snake eats fruit\n        if snake.body[0] == fruit.position:\n            snake.grow()\n            fruit.respawn()\n            score += 1\n\n        # Check for collisions\n        if snake.check_collision():\n            print(f\"Game Over! Your score was: {score}\")\n            # Restart game\n            snake = Snake()\n            fruit = Fruit()\n            score = 0\n\n        # Draw snake\n        for segment in snake.body:\n            pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n        # Draw fruit\n        pygame.draw.rect(screen, RED, (fruit.position[0] * CELL_SIZE, fruit.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n        # Draw score\n        font = pygame.font.Font(None, 36)\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        screen.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10  # Frames per second\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\nclass Snake:\n    def __init__(self):\n        self.body = [(GRID_SIZE//2, GRID_SIZE//2), (GRID_SIZE//2 - 1, GRID_SIZE//2), (GRID_SIZE//2 - 2, GRID_SIZE//2)]\n        self.direction = RIGHT\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        dir_x, dir_y = self.direction\n        new_head = (head_x + dir_x, head_y + dir_y)\n        self.body.insert(0, new_head)\n        self.body.pop()  # Remove the last segment\n\n    def grow(self):\n        self.body.append(self.body[-1])  # Add a new segment at the end\n\n    def change_direction(self, new_direction):\n        if (new_direction[0] * -1, new_direction[1] * -1) != self.direction:\n            self.direction = new_direction\n\n    def collides_with_self(self):\n        return len(self.body) != len(set(self.body))\n\n    def collides_with_wall(self):\n        head_x, head_y = self.body[0]\n        return head_x < 0 or head_x >= GRID_SIZE or head_y < 0 or head_y >= GRID_SIZE\n\n    def draw(self, surface):\n        for segment in self.body:\n            rect = pygame.Rect(segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n            pygame.draw.rect(surface, GREEN, rect)\n\nclass Fruit:\n    def __init__(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def respawn(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def draw(self, surface):\n        rect = pygame.Rect(self.position[0] * CELL_SIZE, self.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE)\n        pygame.draw.rect(surface, RED, rect)\n\ndef main():\n    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption(\"Snake Game\")\n    clock = pygame.time.Clock()\n\n    snake = Snake()\n    fruit = Fruit()\n    score = 0\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction(UP)\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction(DOWN)\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction(LEFT)\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction(RIGHT)\n\n        if not game_over:\n            snake.move()\n\n            # Check for collisions\n            if snake.collides_with_wall() or snake.collides_with_self():\n                game_over = True\n            else:\n                if snake.body[0] == fruit.position:\n                    snake.grow()\n                    score += 1\n                    fruit.respawn()\n\n        # Drawing\n        screen.fill(BLACK)\n        snake.draw(screen)\n        fruit.draw(screen)\n\n        # Display score\n        font = pygame.font.SysFont(None, 35)\n        score_surface = font.render(f'Score: {score}', True, GREEN)\n        screen.blit(score_surface, (10, 10))\n\n        if game_over:\n            game_over_surface = font.render('Game Over! Press R to Restart', True, RED)\n            screen.blit(game_over_surface, (WINDOW_SIZE//2 - 150, WINDOW_SIZE//2))\n\n            keys = pygame.key.get_pressed()\n            if keys[pygame.K_r]:\n                snake = Snake()\n                fruit = Fruit()\n                score = 0\n                game_over = False\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Initialize Pygame\npygame.init()\npygame.display.set_caption('Snake Game')\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\nclock = pygame.time.Clock()\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(window, GREEN, pygame.Rect(segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(window, RED, pygame.Rect(fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef main():\n    # Game variables\n    snake = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n    direction = RIGHT\n    fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n    score = 0\n    game_over = False\n    \n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        # Move the snake\n        if not game_over:\n            head_x, head_y = snake[0]\n            new_head = (head_x + direction[0], head_y + direction[1])\n\n            # Check for collision with walls\n            if new_head[0] < 0 or new_head[0] >= GRID_SIZE or new_head[1] < 0 or new_head[1] >= GRID_SIZE:\n                game_over = True\n\n            # Check for collision with itself\n            if new_head in snake:\n                game_over = True\n\n            # Check for fruit collision\n            if new_head == fruit:\n                snake.insert(0, new_head)\n                score += 1\n                fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n                # Ensure fruit does not spawn on snake\n                while fruit in snake:\n                    fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n            else:\n                snake.insert(0, new_head)\n                snake.pop()\n\n        # Drawing\n        window.fill(BLACK)\n        draw_snake(snake)\n        draw_fruit(fruit)\n\n        # Display score\n        font = pygame.font.SysFont('Arial', 25)\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        window.blit(score_text, (10, 10))\n\n        # Refresh the display\n        pygame.display.flip()\n        clock.tick(FPS)\n\n        # Restart game if game over\n        if game_over:\n            pygame.time.delay(1000)\n            snake = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n            direction = RIGHT\n            fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n            score = 0\n            game_over = False\n\nif __name__ == '__main__':\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\nimport time\n\n# Initialize Pygame\npygame.init()\n\n# Define colors\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nWHITE = (255, 255, 255)\n\n# Window size and cell size\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\n\n# Clock to control the game's frame rate\nclock = pygame.time.Clock()\n\n# Font for displaying score\nfont = pygame.font.SysFont('comicsansms', 35)\n\ndef draw_snake(snake_segments):\n    for segment in snake_segments:\n        pygame.draw.rect(screen, GREEN, pygame.Rect(segment[0], segment[1], CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit_position):\n    pygame.draw.rect(screen, RED, pygame.Rect(fruit_position[0], fruit_position[1], CELL_SIZE, CELL_SIZE))\n\ndef show_score(score):\n    score_surface = font.render(f'Score: {score}', True, WHITE)\n    screen.blit(score_surface, [10, 10])\n\ndef game_loop():\n    # Initial snake settings\n    snake_segments = [[100, 100], [80, 100], [60, 100]]\n    direction = 'RIGHT'\n    fruit_position = [random.randrange(1, GRID_SIZE) * CELL_SIZE,\n                      random.randrange(1, GRID_SIZE) * CELL_SIZE]\n    score = 0\n\n    while True:\n        # Event handling\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            \n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != 'DOWN':\n                    direction = 'UP'\n                elif event.key == pygame.K_DOWN and direction != 'UP':\n                    direction = 'DOWN'\n                elif event.key == pygame.K_LEFT and direction != 'RIGHT':\n                    direction = 'LEFT'\n                elif event.key == pygame.K_RIGHT and direction != 'LEFT':\n                    direction = 'RIGHT'\n\n        # Move snake\n        head_x, head_y = snake_segments[0]\n        if direction == 'UP':\n            head_y -= CELL_SIZE\n        elif direction == 'DOWN':\n            head_y += CELL_SIZE\n        elif direction == 'LEFT':\n            head_x -= CELL_SIZE\n        elif direction == 'RIGHT':\n            head_x += CELL_SIZE\n        \n        # Insert new head\n        new_head = [head_x, head_y]\n        snake_segments.insert(0, new_head)\n\n        # Check for fruit collision\n        if snake_segments[0] == fruit_position:\n            score += 1\n            fruit_position = [random.randrange(1, GRID_SIZE) * CELL_SIZE,\n                              random.randrange(1, GRID_SIZE) * CELL_SIZE]\n        else:\n            snake_segments.pop()\n\n        # Check for wall collision\n        if (head_x < 0 or head_x >= WINDOW_SIZE or\n                head_y < 0 or head_y >= WINDOW_SIZE):\n            return game_restart(score)\n\n        # Check for self collision\n        if snake_segments[0] in snake_segments[1:]:\n            return game_restart(score)\n\n        # Clear screen\n        screen.fill(BLACK)\n\n        # Draw everything\n        draw_snake(snake_segments)\n        draw_fruit(fruit_position)\n        show_score(score)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Control frame rate\n        clock.tick(10)\n\ndef game_restart(score):\n    time.sleep(2)  # Pause before restarting\n    game_loop()\n\n# Start the game\ngame_loop()\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Failed to load module"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Game variables\nsnake_pos = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\nsnake_dir = (1, 0)  # Start moving right\nfruit_pos = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\nscore = 0\n\n# Pygame window setup\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\n\ndef draw_snake(snake_pos):\n    for segment in snake_pos:\n        pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit_pos):\n    pygame.draw.rect(screen, RED, (fruit_pos[0] * CELL_SIZE, fruit_pos[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef restart_game():\n    global snake_pos, snake_dir, fruit_pos, score\n    snake_pos = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n    snake_dir = (1, 0)\n    fruit_pos = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n    score = 0\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_UP and snake_dir != (0, 1):\n                snake_dir = (0, -1)\n            elif event.key == pygame.K_DOWN and snake_dir != (0, -1):\n                snake_dir = (0, 1)\n            elif event.key == pygame.K_LEFT and snake_dir != (1, 0):\n                snake_dir = (-1, 0)\n            elif event.key == pygame.K_RIGHT and snake_dir != (-1, 0):\n                snake_dir = (1, 0)\n\n    # Update snake position\n    new_head = (snake_pos[0][0] + snake_dir[0], snake_pos[0][1] + snake_dir[1])\n    \n    # Check for collisions with walls\n    if (new_head[0] < 0 or new_head[0] >= GRID_SIZE or\n        new_head[1] < 0 or new_head[1] >= GRID_SIZE or\n        new_head in snake_pos):\n        restart_game()\n\n    # Check for fruit collision\n    if new_head == fruit_pos:\n        score += 1\n        snake_pos.insert(0, new_head)  # Grow snake\n        # Generate new fruit position\n        while fruit_pos in snake_pos:\n            fruit_pos = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n    else:\n        snake_pos.insert(0, new_head)  # Move snake\n        snake_pos.pop()  # Remove last segment\n\n    # Draw everything\n    screen.fill(BLACK)\n    draw_snake(snake_pos)\n    draw_fruit(fruit_pos)\n    \n    # Display score\n    font = pygame.font.SysFont('Arial', 25)\n    score_surface = font.render(f'Score: {score}', True, GREEN)\n    screen.blit(score_surface, (10, 10))\n    \n    pygame.display.flip()\n    clock.tick(FPS)\n\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Game settings\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\nclass Snake:\n    def __init__(self):\n        self.body = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n        self.direction = (1, 0)  # Start moving right\n        self.grow = False\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        new_head = (head_x + self.direction[0], head_y + self.direction[1])\n        self.body.insert(0, new_head)\n        if not self.grow:\n            self.body.pop()\n        else:\n            self.grow = False\n\n    def change_direction(self, new_direction):\n        # Prevent reversing\n        if (new_direction[0] * -1, new_direction[1] * -1) != self.direction:\n            self.direction = new_direction\n\n    def eat(self):\n        self.grow = True\n\n    def collides_with_self(self):\n        return self.body[0] in self.body[1:]\n\n    def collides_with_wall(self):\n        head_x, head_y = self.body[0]\n        return head_x < 0 or head_x >= GRID_SIZE or head_y < 0 or head_y >= GRID_SIZE\n\ndef spawn_fruit(snake_body):\n    while True:\n        x = random.randint(0, GRID_SIZE - 1)\n        y = random.randint(0, GRID_SIZE - 1)\n        fruit_position = (x, y)\n        if fruit_position not in snake_body:\n            return fruit_position\n\ndef draw_snake(screen, snake):\n    for segment in snake.body:\n        pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(screen, fruit):\n    pygame.draw.rect(screen, RED, (fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef display_score(screen, score):\n    font = pygame.font.Font(None, 36)\n    score_surface = font.render(f'Score: {score}', True, BLACK)\n    screen.blit(score_surface, (5, 5))\n\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\n    pygame.display.set_caption('Snake Game')\n    clock = pygame.time.Clock()\n\n    snake = Snake()\n    fruit = spawn_fruit(snake.body)\n    score = 0\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction((0, -1))\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction((0, 1))\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction((-1, 0))\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction((1, 0))\n\n        snake.move()\n\n        if snake.collides_with_wall() or snake.collides_with_self():\n            # Restart the game\n            snake = Snake()\n            fruit = spawn_fruit(snake.body)\n            score = 0\n\n        if snake.body[0] == fruit:\n            snake.eat()\n            fruit = spawn_fruit(snake.body)\n            score += 1\n\n        screen.fill(BLACK)\n        draw_snake(screen, snake)\n        draw_fruit(screen, fruit)\n        display_score(screen, score)\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nSNAKE_COLOR = (0, 255, 0)  # Green\nFRUIT_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Set up the game window\nwindow = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\n\n# Function to create a random fruit position\ndef get_random_fruit_position(snake_body):\n    while True:\n        position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        if position not in snake_body:\n            return position\n\n# Main game loop\ndef game_loop():\n    # Initial snake setup\n    snake_body = [(5, 5), (5, 6), (5, 7)]\n    direction = RIGHT\n    fruit_position = get_random_fruit_position(snake_body)\n    score = 0\n    clock = pygame.time.Clock()\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        if not game_over:\n            # Update snake position\n            new_head = (snake_body[0][0] + direction[0], snake_body[0][1] + direction[1])\n            if (new_head[0] < 0 or new_head[0] >= GRID_SIZE or \n                new_head[1] < 0 or new_head[1] >= GRID_SIZE or \n                new_head in snake_body):\n                game_over = True\n            else:\n                snake_body.insert(0, new_head)\n                if new_head == fruit_position:\n                    score += 1\n                    fruit_position = get_random_fruit_position(snake_body)\n                else:\n                    snake_body.pop()\n\n        # Drawing\n        window.fill(BACKGROUND_COLOR)\n        for segment in snake_body:\n            pygame.draw.rect(window, SNAKE_COLOR, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n        pygame.draw.rect(window, FRUIT_COLOR, (fruit_position[0] * CELL_SIZE, fruit_position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n        # Display score\n        font = pygame.font.SysFont(None, 35)\n        score_text = font.render(f'Score: {score}', True, (255, 255, 255))\n        window.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(10)  # Control the speed of the snake\n\n        if game_over:\n            # Show game over screen\n            window.fill(BACKGROUND_COLOR)\n            game_over_text = font.render('Game Over! Press any key to restart', True, (255, 255, 255))\n            final_score_text = font.render(f'Final Score: {score}', True, (255, 255, 255))\n            window.blit(game_over_text, (WINDOW_SIZE // 2 - 200, WINDOW_SIZE // 2 - 20))\n            window.blit(final_score_text, (WINDOW_SIZE // 2 - 100, WINDOW_SIZE // 2 + 20))\n            pygame.display.flip()\n            waiting = True\n            while waiting:\n                for event in pygame.event.get():\n                    if event.type == pygame.QUIT:\n                        pygame.quit()\n                        return\n                    if event.type == pygame.KEYDOWN:\n                        waiting = False\n                        game_loop()  # Restart the game\n\n# Start the game\nif __name__ == \"__main__\":\n    game_loop()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 15\n\n# Colors\nBLACK = (0, 0, 0)\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(screen, GREEN, pygame.Rect(segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(screen, RED, pygame.Rect(fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef check_collision(snake):\n    head = snake[0]\n    # Check wall collision\n    if head[0] < 0 or head[0] >= GRID_SIZE or head[1] < 0 or head[1] >= GRID_SIZE:\n        return True\n    # Check self collision\n    if head in snake[1:]:\n        return True\n    return False\n\ndef restart_game():\n    return [(GRID_SIZE // 2, GRID_SIZE // 2 + i) for i in range(3)], RIGHT, (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1)), 0\n\n# Setup the screen\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\nclock = pygame.time.Clock()\n\n# Game Loop\ndef main():\n    snake, direction, fruit, score = restart_game()\n    running = True\n\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        # Move the snake\n        new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n        snake.insert(0, new_head)\n\n        # Check for fruit collision\n        if snake[0] == fruit:\n            score += 1\n            fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n            while fruit in snake:\n                fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        else:\n            snake.pop()\n\n        # Check for collisions\n        if check_collision(snake):\n            snake, direction, fruit, score = restart_game()\n\n        # Draw everything\n        screen.fill(BLACK)\n        draw_snake(snake)\n        draw_fruit(fruit)\n\n        # Display score\n        font = pygame.font.SysFont(\"Arial\", 24)\n        score_text = font.render(f\"Score: {score}\", True, (255, 255, 255))\n        screen.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": "Missing Snake class or logic"
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": false,
          "overall_passed": false
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Game Window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption(\"Snake Game\")\n\n# Snake class\nclass Snake:\n    def __init__(self):\n        self.body = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n        self.direction = (1, 0)  # Moving right\n        self.grow = False\n\n    def move(self):\n        head_x, head_y = self.body[0]\n        new_head = (head_x + self.direction[0], head_y + self.direction[1])\n        \n        if self.grow:\n            self.body.insert(0, new_head)\n            self.grow = False\n        else:\n            self.body.insert(0, new_head)\n            self.body.pop()\n\n    def change_direction(self, new_direction):\n        if (new_direction[0] * -1, new_direction[1] * -1) != self.direction:\n            self.direction = new_direction\n\n    def grow_snake(self):\n        self.grow = True\n\n    def check_collision(self):\n        head = self.body[0]\n        # Check wall collision\n        if head[0] < 0 or head[0] >= GRID_SIZE or head[1] < 0 or head[1] >= GRID_SIZE:\n            return True\n        # Check self collision\n        if head in self.body[1:]:\n            return True\n        return False\n\n# Fruit class\nclass Fruit:\n    def __init__(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n    def spawn(self):\n        self.position = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n\n# Main Game Function\ndef game_loop():\n    clock = pygame.time.Clock()\n    snake = Snake()\n    fruit = Fruit()\n    score = 0\n    game_over = False\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP:\n                    snake.change_direction((0, -1))\n                elif event.key == pygame.K_DOWN:\n                    snake.change_direction((0, 1))\n                elif event.key == pygame.K_LEFT:\n                    snake.change_direction((-1, 0))\n                elif event.key == pygame.K_RIGHT:\n                    snake.change_direction((1, 0))\n\n        if not game_over:\n            snake.move()\n            if snake.check_collision():\n                game_over = True\n            \n            # Check if snake eats fruit\n            if snake.body[0] == fruit.position:\n                snake.grow_snake()\n                fruit.spawn()\n                score += 1\n        \n        # Drawing\n        screen.fill(BLACK)\n        for segment in snake.body:\n            pygame.draw.rect(screen, GREEN, (segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n        pygame.draw.rect(screen, RED, (fruit.position[0] * CELL_SIZE, fruit.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\n        # Display score\n        font = pygame.font.SysFont(None, 35)\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        screen.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n        # Restart the game if game_over\n        if game_over:\n            pygame.time.wait(1000)\n            snake = Snake()\n            fruit = Fruit()\n            score = 0\n            game_over = False\n\n# Run the game\nif __name__ == '__main__':\n    game_loop()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize pygame\npygame.init()\n\n# Constants\nWINDOW_SIZE = 600\nCELL_SIZE = 20\nGRID_SIZE = WINDOW_SIZE // CELL_SIZE\nFPS = 10\n\n# Colors\nGREEN = (0, 255, 0)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\n\n# Directions\nUP = (0, -1)\nDOWN = (0, 1)\nLEFT = (-1, 0)\nRIGHT = (1, 0)\n\n# Initialize window\nscreen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))\npygame.display.set_caption('Snake Game')\n\ndef draw_snake(snake):\n    for segment in snake:\n        pygame.draw.rect(screen, GREEN, pygame.Rect(segment[0] * CELL_SIZE, segment[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef draw_fruit(fruit):\n    pygame.draw.rect(screen, RED, pygame.Rect(fruit[0] * CELL_SIZE, fruit[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE))\n\ndef main():\n    clock = pygame.time.Clock()\n    font = pygame.font.SysFont('Arial', 24)\n\n    def reset_game():\n        nonlocal snake, fruit, direction, score, game_over\n        snake = [(GRID_SIZE // 2, GRID_SIZE // 2), (GRID_SIZE // 2 - 1, GRID_SIZE // 2), (GRID_SIZE // 2 - 2, GRID_SIZE // 2)]\n        fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n        direction = RIGHT\n        score = 0\n        game_over = False\n\n    reset_game()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                return\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_UP and direction != DOWN:\n                    direction = UP\n                elif event.key == pygame.K_DOWN and direction != UP:\n                    direction = DOWN\n                elif event.key == pygame.K_LEFT and direction != RIGHT:\n                    direction = LEFT\n                elif event.key == pygame.K_RIGHT and direction != LEFT:\n                    direction = RIGHT\n\n        if not game_over:\n            # Move the snake\n            new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n            # Check for collisions with walls\n            if (new_head[0] < 0 or new_head[0] >= GRID_SIZE or\n                new_head[1] < 0 or new_head[1] >= GRID_SIZE or\n                new_head in snake):\n                game_over = True\n            else:\n                # Check if fruit is eaten\n                if new_head == fruit:\n                    snake.insert(0, new_head)\n                    score += 1\n                    fruit = (random.randint(0, GRID_SIZE - 1), random.randint(0, GRID_SIZE - 1))\n                else:\n                    snake.insert(0, new_head)\n                    snake.pop()  # Remove last segment if not eating fruit\n\n        # Drawing\n        screen.fill(BLACK)\n        draw_snake(snake)\n        draw_fruit(fruit)\n        \n        # Display score\n        score_text = font.render(f'Score: {score}', True, GREEN)\n        screen.blit(score_text, (10, 10))\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\n        # Restart the game if game over\n        if game_over:\n            reset_game()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": false,
            "error": "  File \"C:\\Users\\mitra\\AppData\\Local\\Temp\\tmpmmyxr_02.py\", line 40\n    nonlocal snake, fruit, direction, score, game_over\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: no binding for nonlocal 'snake' found\n"
          },
          "runtime": {
            "passed": false,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": false,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": false,
          "runtime_passed": false,
          "semantic_passed": false,
          "overall_passed": false
        }
      }
    ]
  },
  "ball_bouncing": {
    "openai": [
      {
        "code": "import pygame\nimport sys\n\n# Initialize pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Ball properties\nball_pos = [WIDTH // 2, HEIGHT // 2]  # Start at the center\nball_vel = [5, 5]  # Velocity in x and y directions\n\n# Create the window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Ball Bouncing Game')\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball to center\n                ball_pos = [WIDTH // 2, HEIGHT // 2]\n                ball_vel = [5, 5]  # Reset velocity\n\n    # Update ball position\n    ball_pos[0] += ball_vel[0]\n    ball_pos[1] += ball_vel[1]\n\n    # Check for wall collisions\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WIDTH - BALL_RADIUS:\n        ball_vel[0] = -ball_vel[0]  # Reverse x velocity\n\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= HEIGHT - BALL_RADIUS:\n        ball_vel[1] = -ball_vel[1]  # Reverse y velocity\n\n    # Fill the background\n    screen.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(screen, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit pygame\npygame.quit()\nsys.exit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black color\nFPS = 60\n\n# Set up the display\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [random.choice([-3, 3]), random.choice([-3, 3])]\n\n# Game loop\ndef main():\n    clock = pygame.time.Clock()\n    running = True\n\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball position\n                    reset_ball()\n\n        # Update ball position\n        ball_pos[0] += ball_velocity[0]\n        ball_pos[1] += ball_velocity[1]\n\n        # Check for wall collisions\n        if ball_pos[0] - BALL_RADIUS <= 0 or ball_pos[0] + BALL_RADIUS >= WINDOW_WIDTH:\n            ball_velocity[0] = -ball_velocity[0]  # Reverse X velocity\n        if ball_pos[1] - BALL_RADIUS <= 0 or ball_pos[1] + BALL_RADIUS >= WINDOW_HEIGHT:\n            ball_velocity[1] = -ball_velocity[1]  # Reverse Y velocity\n\n        # Fill the background\n        window.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n        # Refresh the display\n        pygame.display.flip()\n\n        # Maintain frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\ndef reset_ball():\n    ball_pos[0] = WINDOW_WIDTH // 2\n    ball_pos[1] = WINDOW_HEIGHT // 2\n    ball_velocity[0] = random.choice([-3, 3])\n    ball_velocity[1] = random.choice([-3, 3])\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black color\nFPS = 60\n\n# Ball class to handle ball properties and behavior\nclass Ball:\n    def __init__(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.velocity_x = random.choice([-5, 5])\n        self.velocity_y = random.choice([-5, 5])\n\n    def move(self):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Check for collisions with walls\n        if self.x <= BALL_RADIUS or self.x >= WINDOW_WIDTH - BALL_RADIUS:\n            self.velocity_x = -self.velocity_x  # Reverse x velocity\n        if self.y <= BALL_RADIUS or self.y >= WINDOW_HEIGHT - BALL_RADIUS:\n            self.velocity_y = -self.velocity_y  # Reverse y velocity\n\n    def reset(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.velocity_x = random.choice([-5, 5])\n        self.velocity_y = random.choice([-5, 5])\n\n# Main function to run the game\ndef main():\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n    clock = pygame.time.Clock()\n    ball = Ball()\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball position with 'R' key\n                    ball.reset()\n\n        # Move the ball and update its position\n        ball.move()\n\n        # Fill the background\n        screen.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        pygame.draw.circle(screen, BALL_COLOR, (int(ball.x), int(ball.y)), BALL_RADIUS)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\n# Entry point of the program\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Ball class to manage ball properties and behaviors\nclass Ball:\n    def __init__(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.velocity_x = random.choice([-5, 5])  # Random initial horizontal velocity\n        self.velocity_y = random.choice([-5, 5])  # Random initial vertical velocity\n\n    def update(self):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Check for wall collisions\n        if self.x <= BALL_RADIUS or self.x >= WINDOW_WIDTH - BALL_RADIUS:\n            self.velocity_x = -self.velocity_x  # Reverse horizontal velocity on collision with side walls\n        if self.y <= BALL_RADIUS or self.y >= WINDOW_HEIGHT - BALL_RADIUS:\n            self.velocity_y = -self.velocity_y  # Reverse vertical velocity on collision with top/bottom walls\n\n    def reset(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.velocity_x = random.choice([-5, 5])\n        self.velocity_y = random.choice([-5, 5])\n\n# Main function to run the game\ndef main():\n    # Set up the display\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n\n    # Create a ball instance\n    ball = Ball()\n\n    clock = pygame.time.Clock()\n    running = True\n\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball when 'R' is pressed\n                    ball.reset()\n\n        # Update ball position\n        ball.update()\n\n        # Clear the screen\n        screen.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        pygame.draw.circle(screen, BALL_COLOR, (int(ball.x), int(ball.y)), BALL_RADIUS)\n\n        # Refresh the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n    # Quit pygame\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\n\n# Set up the display\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WIDTH // 2, HEIGHT // 2]\nball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Game loop control\nrunning = True\nclock = pygame.time.Clock()\n\n# Main game loop\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball position on 'R' key press\n                ball_pos = [WIDTH // 2, HEIGHT // 2]\n                ball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions\n    if ball_pos[0] - BALL_RADIUS <= 0 or ball_pos[0] + BALL_RADIUS >= WIDTH:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse x velocity\n    if ball_pos[1] - BALL_RADIUS <= 0 or ball_pos[1] + BALL_RADIUS >= HEIGHT:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse y velocity\n\n    # Fill the background\n    screen.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(screen, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(60)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Setup the display\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball settings\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Function to reset ball position\ndef reset_ball():\n    ball_pos[0] = WINDOW_WIDTH // 2\n    ball_pos[1] = WINDOW_HEIGHT // 2\n    ball_velocity[0] = random.choice([-5, 5])\n    ball_velocity[1] = random.choice([-5, 5])\n\n# Main game loop\nrunning = True\nclock = pygame.time.Clock()\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset the ball when 'R' is pressed\n                reset_ball()\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for collisions with walls\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse x velocity\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse y velocity\n\n    # Fill background\n    window.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport sys\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH, WINDOW_HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Set up the display\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Bouncing Ball Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]  # Start in the center\nball_vel = [random.choice([-5, 5]), random.choice([-5, 5])]  # Random initial velocity\n\n# Function to reset the ball to the center\ndef reset_ball():\n    global ball_pos, ball_vel\n    ball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n    ball_vel = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Main game loop\ndef main():\n    clock = pygame.time.Clock()\n\n    while True:\n        # Event handling\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball when 'R' is pressed\n                    reset_ball()\n\n        # Update ball position\n        ball_pos[0] += ball_vel[0]\n        ball_pos[1] += ball_vel[1]\n\n        # Check for wall collisions\n        if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n            ball_vel[0] = -ball_vel[0]  # Reverse x velocity\n        if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n            ball_vel[1] = -ball_vel[1]  # Reverse y velocity\n\n        # Fill the background\n        screen.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        pygame.draw.circle(screen, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n# Run the game\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black background\nFPS = 60\n\n# Set up the display\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball class\nclass Ball:\n    def __init__(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.radius = BALL_RADIUS\n        self.color = BALL_COLOR\n        self.velocity_x = random.choice([-4, 4])\n        self.velocity_y = random.choice([-4, 4])\n\n    def update(self):\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Check for wall collisions\n        if self.x - self.radius <= 0 or self.x + self.radius >= WIDTH:\n            self.velocity_x = -self.velocity_x  # Reverse x velocity\n        if self.y - self.radius <= 0 or self.y + self.radius >= HEIGHT:\n            self.velocity_y = -self.velocity_y  # Reverse y velocity\n\n    def reset(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.velocity_x = random.choice([-4, 4])\n        self.velocity_y = random.choice([-4, 4])\n\n    def draw(self, surface):\n        pygame.draw.circle(surface, self.color, (self.x, self.y), self.radius)\n\n# Main game loop\ndef main():\n    clock = pygame.time.Clock()\n    ball = Ball()\n    running = True\n\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Press 'R' to reset\n                    ball.reset()\n\n        # Update ball position\n        ball.update()\n\n        # Draw everything\n        screen.fill(BACKGROUND_COLOR)\n        ball.draw(screen)\n        \n        # Update display\n        pygame.display.flip()\n        \n        # Cap the frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Ball class to handle ball properties and behavior\nclass Ball:\n    def __init__(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.radius = BALL_RADIUS\n        self.vx = random.choice([-5, 5])\n        self.vy = random.choice([-5, 5])\n\n    def update(self):\n        self.x += self.vx\n        self.y += self.vy\n\n        # Check for wall collisions\n        if self.x - self.radius < 0 or self.x + self.radius > WIDTH:\n            self.vx = -self.vx  # Reverse x velocity\n\n        if self.y - self.radius < 0 or self.y + self.radius > HEIGHT:\n            self.vy = -self.vy  # Reverse y velocity\n\n    def reset(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.vx = random.choice([-5, 5])\n        self.vy = random.choice([-5, 5])\n\n    def draw(self, window):\n        pygame.draw.circle(window, BALL_COLOR, (self.x, self.y), self.radius)\n\n# Main function to run the game\ndef main():\n    # Create game window\n    window = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Bouncing Ball Game\")\n    \n    # Create the ball instance\n    ball = Ball()\n    \n    # Game loop\n    clock = pygame.time.Clock()\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                    ball.reset()\n        \n        # Update ball position\n        ball.update()\n\n        # Fill background\n        window.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        ball.draw(window)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n    # Quit Pygame\n    pygame.quit()\n\n# Run the game\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black color\nFPS = 60\n\n# Initialize Pygame\npygame.init()\n\n# Create the window\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [5, 5]  # Initial velocity (x, y)\n\n# Function to reset ball position\ndef reset_ball():\n    ball_pos[0] = WINDOW_WIDTH // 2\n    ball_pos[1] = WINDOW_HEIGHT // 2\n    ball_velocity[0] = 5  # Reset to default velocity\n    ball_velocity[1] = 5  # Reset to default velocity\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                reset_ball()\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse x velocity\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse y velocity\n\n    # Clear the window\n    window.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Clean up\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Ball attributes\nball_pos = [WIDTH // 2, HEIGHT // 2]\nball_velocity = [5, 3]  # Velocity in x and y direction\n\n# Create the window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption('Ball Bouncing Game')\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball position when 'R' is pressed\n                ball_pos = [WIDTH // 2, HEIGHT // 2]\n                ball_velocity = [5, 3]  # Reset velocity if desired\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions\n    if ball_pos[0] - BALL_RADIUS < 0 or ball_pos[0] + BALL_RADIUS > WIDTH:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse x velocity\n\n    if ball_pos[1] - BALL_RADIUS < 0 or ball_pos[1] + BALL_RADIUS > HEIGHT:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse y velocity\n\n    # Clear the screen\n    screen.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(screen, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()\nsys.exit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Setup the display\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_vel = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Function to reset ball to center\ndef reset_ball():\n    ball_pos[0] = WINDOW_WIDTH // 2\n    ball_pos[1] = WINDOW_HEIGHT // 2\n    ball_vel[0] = random.choice([-5, 5])\n    ball_vel[1] = random.choice([-5, 5])\n\n# Game loop\nrunning = True\nclock = pygame.time.Clock()\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                reset_ball()\n\n    # Update ball position\n    ball_pos[0] += ball_vel[0]\n    ball_pos[1] += ball_vel[1]\n\n    # Check for wall collisions\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n        ball_vel[0] = -ball_vel[0]  # Reverse horizontal velocity\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n        ball_vel[1] = -ball_vel[1]  # Reverse vertical velocity\n\n    # Fill the background\n    window.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\nimport sys\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)\nBACKGROUND_COLOR = (0, 0, 0)\nFPS = 60\n\n# Set up the window\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption('Ball Bouncing Game')\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball position\n                ball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n                ball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions\n    if ball_pos[0] - BALL_RADIUS <= 0 or ball_pos[0] + BALL_RADIUS >= WINDOW_WIDTH:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse horizontal velocity\n\n    if ball_pos[1] - BALL_RADIUS <= 0 or ball_pos[1] + BALL_RADIUS >= WINDOW_HEIGHT:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse vertical velocity\n\n    # Fill the background\n    window.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()\nsys.exit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Ball class to manage the ball's behavior\nclass Ball:\n    def __init__(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.radius = BALL_RADIUS\n        self.color = BALL_COLOR\n        self.vx = random.choice([-5, 5])  # Random initial horizontal velocity\n        self.vy = random.choice([-5, 5])  # Random initial vertical velocity\n\n    def move(self):\n        self.x += self.vx\n        self.y += self.vy\n\n        # Check for wall collisions\n        if self.x - self.radius <= 0 or self.x + self.radius >= WIDTH:\n            self.vx = -self.vx  # Reverse horizontal velocity\n        if self.y - self.radius <= 0 or self.y + self.radius >= HEIGHT:\n            self.vy = -self.vy  # Reverse vertical velocity\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, self.color, (self.x, self.y), self.radius)\n\n    def reset(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.vx = random.choice([-5, 5])\n        self.vy = random.choice([-5, 5])\n\n# Main function to run the game\ndef main():\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n    clock = pygame.time.Clock()\n    ball = Ball()\n\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                    ball.reset()\n\n        ball.move()\n\n        # Fill the background\n        screen.fill(BACKGROUND_COLOR)\n        ball.draw(screen)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black background\nFPS = 60\n\n# Ball class to handle ball properties and movement\nclass Ball:\n    def __init__(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.radius = BALL_RADIUS\n        self.vx = 5  # Velocity in x-direction\n        self.vy = 5  # Velocity in y-direction\n\n    def move(self):\n        self.x += self.vx\n        self.y += self.vy\n\n        # Check for collision with walls\n        if self.x - self.radius <= 0 or self.x + self.radius >= WINDOW_WIDTH:\n            self.vx = -self.vx  # Reverse x velocity\n        if self.y - self.radius <= 0 or self.y + self.radius >= WINDOW_HEIGHT:\n            self.vy = -self.vy  # Reverse y velocity\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, BALL_COLOR, (int(self.x), int(self.y)), self.radius)\n\n    def reset(self):\n        self.x = WINDOW_WIDTH // 2\n        self.y = WINDOW_HEIGHT // 2\n        self.vx = 5  # Reset velocity in x-direction\n        self.vy = 5  # Reset velocity in y-direction\n\n# Main function to run the game\ndef main():\n    pygame.init()\n    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n    clock = pygame.time.Clock()\n\n    ball = Ball()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball position when 'R' is pressed\n                    ball.reset()\n\n        # Update ball position\n        ball.move()\n\n        # Drawing\n        screen.fill(BACKGROUND_COLOR)\n        ball.draw(screen)\n\n        pygame.display.flip()\n        clock.tick(FPS)\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black color\nFPS = 60\n\n# Ball class\nclass Ball:\n    def __init__(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.radius = BALL_RADIUS\n        self.velocity_x = random.choice([-5, 5])\n        self.velocity_y = random.choice([-5, 5])\n\n    def update(self):\n        # Update the ball's position\n        self.x += self.velocity_x\n        self.y += self.velocity_y\n\n        # Check for wall collisions\n        if self.x - self.radius <= 0 or self.x + self.radius >= WIDTH:\n            self.velocity_x = -self.velocity_x  # Reverse horizontal velocity\n        if self.y - self.radius <= 0 or self.y + self.radius >= HEIGHT:\n            self.velocity_y = -self.velocity_y  # Reverse vertical velocity\n\n    def reset(self):\n        # Reset the ball to the center\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.velocity_x = random.choice([-5, 5])\n        self.velocity_y = random.choice([-5, 5])\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, BALL_COLOR, (self.x, self.y), self.radius)\n\n# Main function\ndef main():\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n    clock = pygame.time.Clock()\n    ball = Ball()\n    running = True\n\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            if event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                    ball.reset()\n\n        # Update the ball's position\n        ball.update()\n\n        # Fill the background\n        screen.fill(BACKGROUND_COLOR)\n\n        # Draw the ball\n        ball.draw(screen)\n\n        # Update the display\n        pygame.display.flip()\n\n        # Cap the frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Create the game window\nwindow = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Game loop\nrunning = True\nclock = pygame.time.Clock()\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball position\n                ball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n                ball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions and reverse velocity if necessary\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse X velocity\n\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse Y velocity\n\n    # Fill the background\n    window.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(window, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# Constants\nWIDTH, HEIGHT = 800, 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black background\nFPS = 60\n\n# Ball class\nclass Ball:\n    def __init__(self):\n        self.radius = BALL_RADIUS\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.vx = random.choice([-5, 5])  # Random initial x velocity\n        self.vy = random.choice([-5, 5])  # Random initial y velocity\n\n    def move(self):\n        self.x += self.vx\n        self.y += self.vy\n        \n        # Check for wall collisions\n        if self.x - self.radius <= 0 or self.x + self.radius >= WIDTH:\n            self.vx = -self.vx  # Reverse x velocity\n            self.x = max(self.radius, min(self.x, WIDTH - self.radius))  # Keep within bounds\n\n        if self.y - self.radius <= 0 or self.y + self.radius >= HEIGHT:\n            self.vy = -self.vy  # Reverse y velocity\n            self.y = max(self.radius, min(self.y, HEIGHT - self.radius))  # Keep within bounds\n\n    def reset(self):\n        self.x = WIDTH // 2\n        self.y = HEIGHT // 2\n        self.vx = random.choice([-5, 5])\n        self.vy = random.choice([-5, 5])\n\n# Main function\ndef main():\n    # Create window\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\n    pygame.display.set_caption(\"Ball Bouncing Game\")\n    \n    # Create ball\n    ball = Ball()\n    \n    # Game loop\n    clock = pygame.time.Clock()\n    running = True\n    while running:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                running = False\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_r:  # Reset ball position\n                    ball.reset()\n\n        # Move the ball\n        ball.move()\n\n        # Fill the background\n        screen.fill(BACKGROUND_COLOR)\n        \n        # Draw the ball\n        pygame.draw.circle(screen, BALL_COLOR, (int(ball.x), int(ball.y)), ball.radius)\n\n        # Update the display\n        pygame.display.flip()\n        \n        # Cap the frame rate\n        clock.tick(FPS)\n\n    pygame.quit()\n\nif __name__ == \"__main__\":\n    main()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport sys\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red color\nBACKGROUND_COLOR = (0, 0, 0)  # Black color\nBALL_SPEED = [5, 3]  # Initial velocity in x and y direction\n\n# Initialize Pygame\npygame.init()\n\n# Create the window\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Bouncing Ball\")\n\n# Ball's initial position\nball_position = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n\n# Game loop\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset ball on 'R' key press\n                ball_position = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n                BALL_SPEED = [5, 3]  # Reset speed to initial values\n\n    # Update ball position\n    ball_position[0] += BALL_SPEED[0]\n    ball_position[1] += BALL_SPEED[1]\n\n    # Check for wall collisions\n    if ball_position[0] - BALL_RADIUS <= 0 or ball_position[0] + BALL_RADIUS >= WINDOW_WIDTH:\n        BALL_SPEED[0] = -BALL_SPEED[0]  # Reverse x velocity\n    if ball_position[1] - BALL_RADIUS <= 0 or ball_position[1] + BALL_RADIUS >= WINDOW_HEIGHT:\n        BALL_SPEED[1] = -BALL_SPEED[1]  # Reverse y velocity\n\n    # Fill the background\n    screen.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(screen, BALL_COLOR, (int(ball_position[0]), int(ball_position[1])), BALL_RADIUS)\n\n    # Update the display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    pygame.time.Clock().tick(60)\n\n# Quit Pygame\npygame.quit()\nsys.exit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      },
      {
        "code": "import pygame\nimport random\n\n# Constants\nWINDOW_WIDTH = 800\nWINDOW_HEIGHT = 600\nBALL_RADIUS = 20\nBALL_COLOR = (255, 0, 0)  # Red\nBACKGROUND_COLOR = (0, 0, 0)  # Black\nFPS = 60\n\n# Initialize Pygame\npygame.init()\n\n# Create the window\nscreen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))\npygame.display.set_caption(\"Ball Bouncing Game\")\n\n# Ball properties\nball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\nball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n\n# Game loop\nclock = pygame.time.Clock()\nrunning = True\n\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        elif event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_r:  # Reset the ball position\n                ball_pos = [WINDOW_WIDTH // 2, WINDOW_HEIGHT // 2]\n                ball_velocity = [random.choice([-5, 5]), random.choice([-5, 5])]\n    \n    # Update ball position\n    ball_pos[0] += ball_velocity[0]\n    ball_pos[1] += ball_velocity[1]\n\n    # Check for wall collisions\n    if ball_pos[0] <= BALL_RADIUS or ball_pos[0] >= WINDOW_WIDTH - BALL_RADIUS:\n        ball_velocity[0] = -ball_velocity[0]  # Reverse horizontal velocity\n\n    if ball_pos[1] <= BALL_RADIUS or ball_pos[1] >= WINDOW_HEIGHT - BALL_RADIUS:\n        ball_velocity[1] = -ball_velocity[1]  # Reverse vertical velocity\n\n    # Fill the background\n    screen.fill(BACKGROUND_COLOR)\n\n    # Draw the ball\n    pygame.draw.circle(screen, BALL_COLOR, (int(ball_pos[0]), int(ball_pos[1])), BALL_RADIUS)\n\n    # Update display\n    pygame.display.flip()\n\n    # Cap the frame rate\n    clock.tick(FPS)\n\n# Quit Pygame\npygame.quit()",
        "results": {
          "syntax": {
            "passed": true,
            "error": null
          },
          "runtime": {
            "passed": true,
            "error": null,
            "errors": []
          },
          "semantic": {
            "passed": true,
            "error": null
          }
        },
        "summary": {
          "syntax_passed": true,
          "runtime_passed": true,
          "semantic_passed": true,
          "overall_passed": true
        }
      }
    ]
  }
}